<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Advanced Document Rule Builder ‚Äì Monarch Replacement</title>
  
  <script src="https://cdn.tailwindcss.com"></script>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>

  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="monarch-config.js"></script>


  <style>
    .select-text{user-select:text;-webkit-user-select:text}
    .select-text::selection{background-color:#bfdbfe}
    .highlight-single{background-color:#fef3c7;padding:0 2px;border-radius:2px;cursor:pointer}
    .highlight-column{background-color:#d1fae5;padding:0 2px;border-radius:2px;cursor:pointer;border-left:3px solid #10b981}
    .highlight-active{background-color:#93c5fd;outline:2px solid #3b82f6}
    .resize-handle{height:4px;background:#e5e7eb;cursor:ns-resize;transition:background .2s}
    .resize-handle:hover{background:#9ca3af}
    .data-table{font-size:.875rem}
    .data-table th{position:sticky;top:0;background:#f3f4f6;z-index:10}
    .rule-success{border-left:4px solid #10b981;background-color:#f0f9ff}
    .rule-error{border-left:4px solid #ef4444;background-color:#fef2f2}
    @keyframes slideIn{from{opacity:0;transform:translateY(-10px)}to{opacity:1;transform:translateY(0)}}
    .float-panel{animation:slideIn .2s ease-out}
    /* New styles for highlights */
    .match-pattern { background-color: rgba(34, 197, 94, 0.3); cursor: pointer; }
    .match-position { background-color: rgba(34, 197, 94, 0.3); cursor: pointer; }
    .match-single { background-color: rgba(34, 197, 94, 0.3); cursor: pointer; }
    .match-append { background-color: rgba(255, 255, 0, 0.4); cursor: pointer; border-left: 2px solid #eab308; }
    .match-excluded { background-color: rgba(239, 68, 68, 0.3); cursor: pointer; border-left: 2px solid #ef4444; }
    .group-boundary { border: 2px dashed rgba(34, 197, 94, 0.5); border-radius: 4px; padding: 2px; margin: 1px 0; }
    /* Column Mapping Inspector styles */
    .column-overlay [role="slider"] {
      pointer-events: auto !important; /* Ensure handles can receive events even if parent has pointer-events: none */
    }
    .column-overlay [role="slider"]:focus {
      outline: 2px solid rgba(0, 128, 255, 0.9);
      outline-offset: 1px;
    }
    .column-overlay [role="slider"]:hover {
      background: rgba(0, 128, 255, 0.3) !important;
    }
    .column-overlay input {
      pointer-events: auto !important; /* Ensure input fields can receive events */
    }
    /* Delete button styles */
    .column-overlay button[aria-label^="Delete column"] {
      transition: background-color 0.2s, transform 0.1s;
    }
    .column-overlay button[aria-label^="Delete column"]:hover {
      background: rgba(220, 38, 38, 1) !important;
      transform: scale(1.1);
    }
    .column-overlay button[aria-label^="Delete column"]:active {
      transform: scale(0.95);
    }
  </style>
</head>
<body class="bg-gray-100">
  <div id="root"></div>

  <script type="text/babel">
    // Simple icon components
    const makeStubIcon = (label) => (props) => (
      <span
        {...props}
        title={label}
        style={{display:'inline-block',width:(props?.size||16),height:(props?.size||16),fontSize:'0.75rem',textAlign:'center', ...props?.style}}>
        {label}
      </span>
    );

    const FileText      = makeStubIcon('üìÑ');
    const Upload        = makeStubIcon('‚¨ÜÔ∏è');
    const MousePointer  = makeStubIcon('üñ±Ô∏è');
    const TableIcon     = makeStubIcon('üìä');
    const ListIcon      = makeStubIcon('üìã');
    const XIcon         = makeStubIcon('‚úñÔ∏è');
    const Sparkles      = makeStubIcon('‚ú®');
    const LinkIcon      = makeStubIcon('üîó');

    const { useState, useRef, useEffect, useCallback, useMemo } = React;
    // Simple performance optimization for large files

    // Debounce hook for performance optimization
    const useDebounce = (value, delay) => {
      const [debouncedValue, setDebouncedValue] = useState(value);
      
      useEffect(() => {
        const handler = setTimeout(() => {
          setDebouncedValue(value);
        }, delay);
        
        return () => {
          clearTimeout(handler);
        };
      }, [value, delay]);
      
      return debouncedValue;
    };

    // Web Worker for heavy computations
    const createWorker = () => {
      const workerCode = `
        self.onmessage = function(e) {
          const { type, data } = e.data;
          
          if (type === 'PROCESS_EXTRACTION') {
            const { fileContent, rules, excludePatterns, columnMapping } = data;
            
            // Process extraction in worker
            const isLineExcluded = (line) => {
              const normalize = (str) => {
                return str.replace(/[0-9-=]/g, ' ').toLowerCase().replace(/\s+/g, ' ').trim();
              };

              return excludePatterns.some(pattern => {
                if (pattern.isFuzzy) {
                  // Fuzzy matching: normalize out variables like page numbers/dates
                  return normalize(line).includes(normalize(pattern.pattern));
                } else if (pattern.isRegex) {
                  try {
                    return new RegExp(pattern.pattern, 'i').test(line);
                  } catch {
                    return false;
                  }
                } else {
                  return line.toLowerCase().includes(pattern.pattern.toLowerCase());
                }
              });
            };

            // Column mapping utilities
            const sliceLineByBoundaries = (line, boundaries) => {
              return boundaries.map(b => {
                const s = Math.max(0, b.start - 1);
                const e = Math.min(line.length, b.end);
                return line.slice(s, e).trimEnd();
              });
            };

            // Apply column mapping if available
            const applyColumnMapping = (data, columnMapping) => {
              if (!columnMapping || !columnMapping.spec || !columnMapping.spec.boundaries) {
                return data;
              }

              const boundaries = columnMapping.spec.boundaries;
              const fieldNames = {};

              // Create mapping from column IDs to field names
              if (columnMapping.mappings) {
                columnMapping.mappings.forEach(mapping => {
                  fieldNames[mapping.columnId] = mapping.fieldName;
                });
              }

              // Apply slicing to each row
              return data.map(row => {
                const slicedData = sliceLineByBoundaries(row._originalLine || '', boundaries);
                const newRow = {};

                boundaries.forEach((boundary, idx) => {
                  const fieldName = fieldNames[boundary.id] || \`Column \${idx + 1}\`;
                  newRow[fieldName] = slicedData[idx] || '';
                });

                return newRow;
              });
            };

            // Transform data into proper table structure
            const primaryRules = rules.filter(r => r.ruleType !== 'APPEND');
            
            if (primaryRules.length === 0) {
              self.postMessage({ type: 'EXTRACTION_COMPLETE', data: [] });
              return;
            }
            
            // Process each rule's data to create consistent table rows
            const processedRules = primaryRules.map(rule => {
              // Only use testResults if they exist and have actual values
              // Never fall back to rule.text/pattern as that would show "column:1" etc.
              const data = (rule.testResults && rule.testResults.length > 0) ? 
                rule.testResults
                  .filter(result => !result.error && !result.isEmpty)
                  .map(result => result.value || '') 
                : [];
              
              return {
                fieldName: rule.fieldName,
                processedData: data
              };
            });
            
            // Create table rows from processed rules
            const processedData = [];
            
            // Check if any rule has multiple values
            const multiValueRules = processedRules.filter(r => r.processedData && r.processedData.length > 1);
            
            if (multiValueRules.length > 0) {
              // Create multiple rows - ensure all rules contribute to each row
              const maxRows = Math.max(...processedRules.map(r => r.processedData ? r.processedData.length : 1));
              const limitedMaxRows = maxRows; // No limit with virtualized rendering
              
              for (let i = 0; i < limitedMaxRows; i++) {
                const row = {};
                processedRules.forEach(rule => {
                  const key = rule.fieldName;
                  if (rule.processedData && rule.processedData.length > i) {
                    // Use the specific value for this row
                    row[key] = rule.processedData[i];
                  } else if (rule.processedData && rule.processedData.length === 1) {
                    // Single value rule - repeat for all rows
                    row[key] = rule.processedData[0];
                  } else {
                    // No data available - use empty string to maintain structure
                    row[key] = '';
                  }
                });
                processedData.push(row);
              }
            } else {
              // Single row - but still preserve empty values
              const row = {};
              processedRules.forEach(r => {
                const key = r.fieldName;
                // Only use processedData, never fall back to rule.text/pattern
                row[key] = r.processedData?.[0] || '';
              });
              processedData.push(row);
            }

            // Apply column mapping if available
            const finalData = applyColumnMapping(processedData, columnMapping);

            // Send data in chunks to prevent UI freezing
            const chunkSize = 1000;
            if (finalData.length > chunkSize) {
              for (let i = 0; i < finalData.length; i += chunkSize) {
                self.postMessage({
                  type: 'EXTRACTION_CHUNK',
                  data: finalData.slice(i, i + chunkSize),
                  progress: Math.round((i / finalData.length) * 100)
                });
              }
              self.postMessage({ type: 'EXTRACTION_COMPLETE', totalItems: finalData.length });
            } else {
              // Small datasets can be sent directly
              self.postMessage({ type: 'EXTRACTION_COMPLETE', data: finalData });
            }
          }
          
          // Helper function for trailing negatives (unicode escapes to avoid paste issues)
          const handleTrailingNegative = (val) => {
            val = val.trim();
            const trailingMinusRegex = /[\\u002D\\u2212\\u2013\\u2014]$/; // ASCII -, math minus, en-dash, em-dash at end
            if (trailingMinusRegex.test(val)) {
              const cleanVal = val.replace(trailingMinusRegex, '').trim();
              return '-' + cleanVal;
            }
            return val;
          };
          
          // Test if a line would be excluded by a specific pattern
          const wouldLineBeExcluded = (line, pattern) => {
            const lineClean = line.trim().toLowerCase();
            const patternText = pattern.pattern.toLowerCase();
            
            if (lineClean === '') return false;  // NEW: Explicitly skip empty lines unless pattern is empty (which it won't be for headers)
            
            if (!pattern.isRegex) {
              if (pattern.isFuzzy) {
                // IMPROVED fuzzy logic with better precision to prevent over-matching
                if (lineClean === patternText) return true;
                
                // Only check substring inclusion for longer patterns to avoid false positives
                if (patternText.length > 4) {
                  if (lineClean.includes(patternText)) return true;
                  if (patternText.includes(lineClean) && lineClean.length > 3) return true;
                }
                
                const patternWords = patternText.split(/\\s+/).filter(w => w.length > 3);
                const lineWords = lineClean.split(/\\s+/).filter(w => w.length > 3);
                
                if (patternWords.length > 0 && lineWords.length > 0) {
                  const matchingWords = patternWords.filter(pw => 
                    lineWords.some(lw => {
                      // More conservative matching - require substantial overlap
                      if (lw === pw) return true; // Exact word match
                      if (lw.length >= 4 && pw.length >= 4) {
                        // Only allow partial matches for longer words
                        return lw.includes(pw) || pw.includes(lw);
                      }
                      return false;
                    })
                  );
                  // Require at least 50% of pattern words to match, minimum 1, maximum prevents over-matching
                  const requiredMatches = Math.max(1, Math.min(Math.ceil(patternWords.length * 0.5), 3));
                  if (matchingWords.length >= requiredMatches) return true;
                }
                return false;
              } else {
                // CHANGED: Strict exact match only (trimmed, case-insensitive)
                return lineClean === patternText;
              }
            } else {
              // Regex pattern matching (unchanged)
              try {
                const regex = new RegExp(patternText, 'i');
                return regex.test(lineClean);
              } catch (e) {
                return false;
              }
            }
          };
          
          // Helper function to resolve column identifier (number or name) to column index
          function resolveColumnIndex(columnIdentifier, columnMapping) {
            // Remove quotes if present (e.g., "Inv Date" -> Inv Date)
            let identifier = columnIdentifier.trim();
            if ((identifier.startsWith('"') && identifier.endsWith('"')) || 
                (identifier.startsWith("'") && identifier.endsWith("'"))) {
              identifier = identifier.slice(1, -1).trim();
            }
            
            // If it's already a number, return it
            const num = parseInt(identifier);
            if (!isNaN(num) && num.toString() === identifier) {
              return num;
            }
            
            // Otherwise, treat it as a field name and look it up
            if (columnMapping && columnMapping.spec && columnMapping.spec.boundaries && columnMapping.mappings) {
              // Find the mapping with this field name (case-insensitive, trimmed)
              const normalizedName = identifier.toLowerCase().trim();
              const mapping = columnMapping.mappings.find(m => 
                m.fieldName && m.fieldName.toLowerCase().trim() === normalizedName
              );
              
              if (mapping) {
                // Find the index of this columnId in the sorted boundaries
                const sortedBoundaries = [...columnMapping.spec.boundaries].sort((a, b) => a.start - b.start);
                const index = sortedBoundaries.findIndex(b => b.id === mapping.columnId);
                if (index >= 0) {
                  return index + 1; // Return 1-based index
                }
              } else {
                console.warn('‚ö†Ô∏è resolveColumnIndex - No mapping found for:', normalizedName);
              }
            } else {
              console.warn('‚ö†Ô∏è resolveColumnIndex - columnMapping missing or invalid:', {
                hasColumnMapping: !!columnMapping,
                hasSpec: !!(columnMapping && columnMapping.spec),
                hasBoundaries: !!(columnMapping && columnMapping.spec && columnMapping.spec.boundaries),
                hasMappings: !!(columnMapping && columnMapping.mappings)
              });
            }
            
            // If not found, return null
            return null;
          }
          
          // Synchronous computation with safety limits - PERFORMANCE OPTIMIZED
          const computeTestResultsSync = (config, isLineExcludedFn, hierarchySettings, fileContent) => {
            const fieldName = config.fieldName || 'Unnamed Rule';
            console.log('üßÆ Computing test results for:', fieldName, 'Type:', config.ruleType);
            
            // Use fileContent passed as parameter
            const contentToUse = fileContent || '';
            // Use cached lines for efficiency
            const linesToUse = contentToUse.split('\\n');
            
            if (!config.pattern || !contentToUse) {
              console.log('‚ö†Ô∏è Missing pattern or file content for:', fieldName);
              return [];
            }
            
            const isLargeFile = linesToUse.length > 10000;
            const processingContent = contentToUse;
            
            // Add processing limit for safety
            const maxMatches = isLargeFile ? 500 : 10000; // Limit matches for large files
            const maxIterations = isLargeFile ? 1000 : 50000; // Prevent infinite loops
            
            // Determine hierarchy context for filtering lines
            const ruleLevel = config.level === 'append' ? 'append' : 'primary';
            let primaryLineRegex = null;
            
            if (hierarchySettings?.mode && hierarchySettings?.identifier) {
              try {
                primaryLineRegex = new RegExp(hierarchySettings.identifier);
              } catch (error) {
                console.warn('Invalid primaryLineIdentifier regex:', hierarchySettings.identifier, error);
                primaryLineRegex = /(?!)/; // Non-matching regex as fallback
              }
            }
            
            // Get columnPositions and columnMapping from hierarchySettings
            let columnPositions = hierarchySettings?.columnPositions || null;
            const columnMapping = hierarchySettings?.columnMapping || null;
            
            // Compute columnPositions from columnMapping if available (prioritize columnMapping)
            if (columnMapping && columnMapping.spec && columnMapping.spec.boundaries && columnMapping.spec.boundaries.length > 0) {
              columnPositions = columnMapping.spec.boundaries
                .slice()
                .sort((a, b) => a.start - b.start)
                .map(b => ({
                  start: Math.max(0, (b.start ?? 1) - 1),
                  end: Math.max(0, (b.end ?? b.start) - 1),
                  isMerged: false
                }));
            }
            
            // Local resolver function that uses the columnMapping parameter
            const resolveColumnIndexLocal = (columnIdentifier) => {
              // Remove quotes if present (e.g., "Inv Date" -> Inv Date)
              let identifier = columnIdentifier.trim();
              if ((identifier.startsWith('"') && identifier.endsWith('"')) || 
                  (identifier.startsWith("'") && identifier.endsWith("'"))) {
                identifier = identifier.slice(1, -1).trim();
              }
              
              // If it's already a number, return it
              const num = parseInt(identifier);
              if (!isNaN(num) && num.toString() === identifier) {
                return num;
              }
              
              // Otherwise, treat it as a field name and look it up using columnMapping
              if (columnMapping && columnMapping.spec && columnMapping.spec.boundaries && columnMapping.mappings) {
                // Find the mapping with this field name (case-insensitive, trimmed)
                const normalizedName = identifier.toLowerCase().trim();
                const mapping = columnMapping.mappings.find(m => 
                  m.fieldName && m.fieldName.toLowerCase().trim() === normalizedName
                );
                
                if (mapping) {
                  // Find the index of this columnId in the sorted boundaries
                  const sortedBoundaries = [...columnMapping.spec.boundaries].sort((a, b) => a.start - b.start);
                  const index = sortedBoundaries.findIndex(b => b.id === mapping.columnId);
                  if (index >= 0) {
                    return index + 1; // Return 1-based index
                  }
                }
              }
              
              return null;
            };
            
            try {
              let matches = [];
              let totalIterations = 0;
              
              if (config.ruleType === 'PATTERN') {
                const regex = new RegExp(config.pattern, 'gim');
                let match;
                
                if (!hierarchySettings?.mode || !primaryLineRegex) {
                  // Original logic for non-hierarchy mode
                  let matchCount = 0;
                  while ((match = regex.exec(processingContent)) !== null) {
                    totalIterations++;
                    if (totalIterations > 50000) {
                      console.warn('‚ö†Ô∏è Max iterations reached for:', fieldName);
                      break;
                    }
                    
                    const fullMatch = match[0];
                    const value = match[1] !== undefined ? match[1] : fullMatch;
                    const fullIndex = match.index;
                    const valueOffset = fullMatch.indexOf(value);
                    const startIndex = fullIndex + valueOffset;
                    const length = value.length;
                    const trimmedValue = value.trim();
                    matches.push({
                      value: trimmedValue,
                      fullMatch,
                      startIndex,
                      length,
                      isEmpty: trimmedValue === ''
                    });
                    matchCount++;
                  }
                } else {
                  // Hierarchy-aware logic: filter lines before testing
                  const lines = linesToUse;
                  let currentPos = 0;
                  
                  lines.forEach((line, idx) => {
                    if (isLineExcludedFn(line)) {
                      currentPos += line.length + 1;
                      return;
                    }
                    
                    // Apply hierarchy filter
                    const isPrimaryLine = primaryLineRegex.test(line);
                    if (ruleLevel === 'primary' && !isPrimaryLine) {
                      currentPos += line.length + 1;
                      return;
                    }
                    if (ruleLevel === 'append' && isPrimaryLine) {
                      currentPos += line.length + 1;
                      return;
                    }
                    
                    // Test regex on this single line
                    let lineMatch;
                    const lineRegex = new RegExp(config.pattern, 'gim');
                    while ((lineMatch = lineRegex.exec(line)) !== null) {
                      totalIterations++;
                      if (totalIterations > 50000) {
                        console.warn('‚ö†Ô∏è Max iterations reached for:', fieldName);
                        return;
                      }
                      
                      const fullMatch = lineMatch[0];
                      const value = lineMatch[1] !== undefined ? lineMatch[1] : fullMatch;
                      const lineStartIndex = lineMatch.index;
                      const valueOffset = fullMatch.indexOf(value);
                      const startIndexInLine = lineStartIndex + valueOffset;
                      const documentStartIndex = currentPos + startIndexInLine;
                      const length = value.length;
                      const trimmedValue = value.trim();
                      
                      matches.push({
                        value: trimmedValue,
                        fullMatch,
                        startIndex: documentStartIndex,
                        length,
                        isEmpty: trimmedValue === ''
                      });
                    }
                    
                    currentPos += line.length + 1;
                  });
                }
              } else if (config.ruleType === 'SINGLE') {
                console.log('üìù Processing SINGLE rule for:', fieldName);
                // Escape special regex characters - build pattern string to avoid template literal parsing issues
                const escapePattern = '[.*+?^' + '$' + '{}()|[\\\\]\\\\]';
                const escapeRegex = new RegExp(escapePattern, 'g');
                const escapedPattern = config.pattern.replace(escapeRegex, '\\\\$&');
                console.log('üîí Escaped pattern for', fieldName, ':', escapedPattern);
                
                if (!hierarchySettings?.mode || !primaryLineRegex) {
                  // Original logic for non-hierarchy mode
                  const regex = new RegExp(escapedPattern, 'gi');
                  let match;
                  let matchCount = 0;
                  while ((match = regex.exec(processingContent)) !== null && matchCount < maxMatches) {
                    totalIterations++;
                    if (totalIterations > 50000) {
                      console.warn('‚ö†Ô∏è Max iterations reached for:', fieldName);
                      break;
                    }
                    
                    const fullMatch = match[0];
                    const value = fullMatch;
                    const startIndex = match.index;
                    const length = value.length;
                    matches.push({
                      value,
                      fullMatch,
                      startIndex,
                      length
                    });
                    matchCount++;
                  }
                } else {
                  // Hierarchy-aware logic: filter lines before testing
                  const lines = linesToUse;
                  let currentPos = 0;
                  
                  lines.forEach((line, idx) => {
                    if (isLineExcludedFn(line)) {
                      currentPos += line.length + 1;
                      return;
                    }
                    
                    // Apply hierarchy filter
                    const isPrimaryLine = primaryLineRegex.test(line);
                    if (ruleLevel === 'primary' && !isPrimaryLine) {
                      currentPos += line.length + 1;
                      return;
                    }
                    if (ruleLevel === 'append' && isPrimaryLine) {
                      currentPos += line.length + 1;
                      return;
                    }
                    
                    // Test regex on this single line
                    let lineMatch;
                    const lineRegex = new RegExp(escapedPattern, 'gi');
                    let matchCount = 0;
                    while ((lineMatch = lineRegex.exec(line)) !== null && matchCount < maxMatches) {
                      totalIterations++;
                      if (totalIterations > 50000) {
                        console.warn('‚ö†Ô∏è Max iterations reached for:', fieldName);
                        return;
                      }
                      
                      const fullMatch = lineMatch[0];
                      const value = fullMatch;
                      const lineStartIndex = lineMatch.index;
                      const documentStartIndex = currentPos + lineStartIndex;
                      const length = value.length;
                      
                      matches.push({
                        value,
                        fullMatch,
                        startIndex: documentStartIndex,
                        length
                      });
                      matchCount++;
                    }
                    
                    currentPos += line.length + 1;
                  });
                }
              } else if (config.ruleType === 'POSITION') {
                // Use full lines array with virtualized highlighting
                const lines = linesToUse;
                let currentPos = 0;
                let matchCount = 0;
                lines.forEach((line, idx) => {
                  if (isLineExcludedFn(line)) {
                    currentPos += line.length + 1;
                    return;
                  }
                  
                  // Apply hierarchy filter if in hierarchy mode
                  if (hierarchySettings?.mode && primaryLineRegex) {
                    const isPrimaryLine = primaryLineRegex.test(line);
                    if (ruleLevel === 'primary' && !isPrimaryLine) {
                      currentPos += line.length + 1;
                      return;
                    }
                    if (ruleLevel === 'append' && isPrimaryLine) {
                      currentPos += line.length + 1;
                      return;
                    }
                  }
                  
                  if (line.match(/^[-\\s]*$/) || line.match(/^-{5,}/)) {
                    currentPos += line.length + 1;
                    return;
                  }
                  
                  if (config.pattern.startsWith('line:')) {
                    const lineNum = parseInt(config.pattern.split(':')[1]);
                    if (idx + 1 === lineNum) {
                      let value = line.trim();
                      const firstNonSpace = line.search(/\\S/);
                      const startIndex = currentPos + (firstNonSpace >= 0 ? firstNonSpace : 0);
                      const length = value.length;
                      if (value) {
                        matches.push({ 
                          value, 
                          fullMatch: line, 
                          startIndex, 
                          length,
                          lineNumber: idx + 1 
                        });
                      }
                    }
                  } else if (config.pattern.startsWith('column:')) {
                    const columnSpec = config.pattern.split(':')[1].trim();
                    
                    if (columnSpec.includes('-')) {
                      // Range-based extraction: column:1-20 (character positions, not column names)
                      const [start, end] = columnSpec.split('-').map(n => parseInt(n));
                      
                      // --- START FIX ---
                      if (line.length >= start) {
                        // Line is long enough to potentially have a value
                        const sub = line.substring(start - 1, end);
                        let value = sub.trim();
                        
                        // Always create a match, even if empty, to maintain column alignment
                        let startIndex, displayLength;
                        
                        if (value && !value.match(/^[-\\s]*$/)) {
                          // Non-empty value
                          const firstNonSpace = sub.search(/\\S/);
                          startIndex = currentPos + (start - 1) + (firstNonSpace >= 0 ? firstNonSpace : 0);
                          displayLength = value.length;
                          
                          // Handle trailing negatives for data extraction
                          if (config.dataType === 'NUMBER' || config.dataType === 'CURRENCY') {
                            if (end < line.length && /[\\u002D\\u2212\\u2013\\u2014]/.test(line[end])) {
                              value += line[end]; // Extract the negative
                            }
                          }

                          value = handleTrailingNegative(value);
                          
                          // We removed the buggy validation, so this part is clean.
                          
                        } else {
                          // Empty value - highlight minimal position
                          value = '';
                          const rangeStart = Math.max(0, start - 1);
                          let actualStart = Math.min(rangeStart, line.length - 1);
                          if (actualStart < 0) actualStart = 0; // Handle completely empty lines
                          startIndex = currentPos + actualStart;
                          displayLength = 1;
                        }

                        matches.push({ 
                          value, 
                          fullMatch: line, 
                          startIndex, 
                          length: displayLength,
                          lineNumber: idx + 1,
                          isEmpty: value === ''
                        });
                      } else {
                        // Line is SHORTER than the start position.
                        // This is an empty match. Add it to the results.
                        matches.push({
                            value: '',
                            fullMatch: line,
                            startIndex: currentPos + Math.max(0, line.length - 1), // Highlight end of short line
                            length: 1, // Minimal highlight
                            lineNumber: idx + 1,
                            isEmpty: true
                        });
                      }
                      // --- END FIX ---

                    } else {
                      // Smart column: Use fixed-width if detected, else fallback to split
                      // Support both numeric (column:1) and named (column:"Inv Date") references
                      const columnNum = resolveColumnIndexLocal(columnSpec);
                      
                      if (columnNum === null) {
                        // Invalid column name or number, skip this line
                        console.warn('‚ö†Ô∏è Could not resolve column:', columnSpec, 'columnMapping available:', !!columnMapping);
                        currentPos += line.length + 1;
                        return;
                      }
                      
                      let value = '';
                      let startIndex;
                      let length;
                      let isEmpty = false;
                      
                      if (columnPositions && columnPositions.length >= columnNum) {
                        // Fixed-width mode with proper empty column handling
                        const pos = columnPositions[columnNum - 1];
                        const sub = line.substring(pos.start, pos.end + 1);
                        value = sub.trim();
                        
                        if (pos.isMerged && value) {
                          if (config.dataType === 'TEXT' || config.dataType === 'DATE') {
                            value = value.replace(/\\s{2,}.*$/, '').trim();
                          } else {
                            value = value.replace(/^.*\\s{2,}/, '').trim();
                          }
                        }
                        
                        let displayLength, valuePos;
                        
                        if (value) {
                          // Non-empty value
                          valuePos = sub.indexOf(value);
                          if (valuePos < 0) {
                            valuePos = sub.search(/\\S/) >= 0 ? sub.search(/\\S/) : 0;
                          }
                          displayLength = value.length;
                          
                          // Handle trailing negatives for data extraction
                          if (config.dataType === 'NUMBER' || config.dataType === 'CURRENCY') {
                            if (pos.end + 1 < line.length && /[\\u002D\\u2212\\u2013\\u2014]/.test(line[pos.end + 1])) {
                              value += line[pos.end + 1]; // Extract the negative
                              // BUT keep displayLength as original for clean highlighting
                            }
                          }
                          
                          value = handleTrailingNegative(value);
                          
                          // Validation after handling - if invalid, treat as empty but still include
                          if ((config.dataType === 'NUMBER' || config.dataType === 'CURRENCY') && !value.replace(/,/g, '').match(/^-?\\d+\\.?\\d*$/)) {
                            value = '';
                            isEmpty = true;
                            // For invalid values, highlight first position of column
                            valuePos = 0;
                            displayLength = 1;
                          }
                        } else {
                          // Empty column - highlight minimal position
                          isEmpty = true;
                          valuePos = 0;
                          displayLength = 1;
                        }
                        
                        startIndex = currentPos + pos.start + valuePos;
                        length = displayLength;
                        matches.push({ 
                          value, 
                          fullMatch: line, 
                          startIndex, 
                          length, 
                          lineNumber: idx + 1,
                          isEmpty
                        });
                      } else {
                        // Enhanced fallback split mode with empty column preservation
                        const originalColumns = line.split(/\\s{2,}/);
                        const columns = originalColumns.map(col => col.trim());
                        
                        // Ensure we have enough columns (pad with empty if needed)
                        while (columns.length < columnNum) {
                          columns.push('');
                        }
                        
                        if (columns.length >= columnNum) {
                          value = columns[columnNum - 1] || '';
                          isEmpty = value === '';
                          
                          // Find position of this column in original line
                          let pos = 0;
                          let foundStart = -1;
                          
                          for (let c = 0; c < columnNum; c++) {
                            if (c < originalColumns.length && originalColumns[c]) {
                              const originalCol = originalColumns[c];
                              const found = line.indexOf(originalCol, pos);
                              if (found !== -1) {
                                if (c === columnNum - 1) {
                                  // Found our target column
                                  if (!isEmpty) {
                                    foundStart = found + originalCol.indexOf(value);
                                    if (foundStart < found) foundStart = found;
                                  } else {
                                    // Empty column - point to end of previous column or start of line
                                    foundStart = found + originalCol.length;
                                  }
                                  break;
                                }
                                pos = found + originalCol.length;
                                // Skip whitespace
                                while (pos < line.length && /\\s/.test(line[pos])) pos++;
                              }
                            } else if (c === columnNum - 1) {
                              // This is our target column but it doesn't exist in original
                              foundStart = Math.min(pos, line.length - 1);
                              isEmpty = true;
                              value = '';
                              break;
                            }
                          }
                          
                          if (!isEmpty) {
                            // Handle trailing negatives for data extraction
                            if (foundStart >= 0) {
                              const end = foundStart + value.length;
                              if (config.dataType === 'NUMBER' || config.dataType === 'CURRENCY') {
                                if (end < line.length && /[\\u002D\\u2212\\u2013\\u2014]/.test(line[end])) {
                                  value += line[end]; // Extract the negative
                                  // Keep original length for highlighting
                                }
                              }
                            }
                            
                            value = handleTrailingNegative(value);
                            
                            // Validation - if invalid, treat as empty but still include
                            if ((config.dataType === 'NUMBER' || config.dataType === 'CURRENCY') && !value.replace(/,/g, '').match(/^-?\\d+\\.?\\d*$/)) {
                              value = '';
                              isEmpty = true;
                            }
                          }
                          
                          // Calculate highlighting parameters
                          let displayLength;
                          if (isEmpty) {
                            displayLength = 1; // Minimal highlight for empty values
                            // Ensure we don't go beyond line length
                            if (foundStart >= line.length) {
                              foundStart = Math.max(0, line.length - 1);
                            }
                          } else {
                            displayLength = columns[columnNum - 1].length; // Use original column length
                          }
                          
                          startIndex = currentPos + Math.max(0, foundStart);
                          length = displayLength;
                          matches.push({ 
                            value, 
                            fullMatch: line, 
                            startIndex, 
                            length, 
                            lineNumber: idx + 1,
                            isEmpty
                          });
                        }
                      }
                    }
                  } else if (config.pattern.startsWith('chars:')) {
                    const [start, end] = config.pattern.split(':')[1].split('-').map(n => parseInt(n));
                    if (line.length >= start) {
                      const sub = line.substring(start - 1, end);
                      let value = sub.trim();
                      if (value) {
                        const firstNonSpace = sub.search(/\\S/) >= 0 ? sub.search(/\\S/) : 0;
                        const displayLength = value.length; // Original length for highlighting
                        
                        // Handle trailing negatives for data extraction
                        if (config.dataType === 'NUMBER' || config.dataType === 'CURRENCY') {
                          if (end < line.length && /[\\u002D\\u2212\\u2013\\u2014]/.test(line[end])) {
                            value += line[end]; // Extract the negative
                            // BUT keep displayLength as original for clean highlighting
                          }
                        }
                        
                        value = handleTrailingNegative(value);
                        
                        // Validation after handling
                        if ((config.dataType === 'NUMBER' || config.dataType === 'CURRENCY') && !value.replace(/,/g, '').match(/^-?\\d+\\.?\\d*$/)) {
                          currentPos += line.length + 1;
                          return;
                        }
                        
                        const startIndex = currentPos + (start - 1) + firstNonSpace;
                        matches.push({ 
                          value, 
                          fullMatch: line, 
                          startIndex,
                          length: displayLength, // Use original length for highlighting
                          lineNumber: idx + 1 
                        });
                      }
                    }
                  }
                  currentPos += line.length + 1;
                });
              } else if (config.ruleType === 'SINGLE') {
                // Escape special regex characters - build pattern string to avoid template literal parsing issues
                const escapePattern = '[.*+?^' + '$' + '{}()|[\\\\]\\\\]';
                const escapeRegex = new RegExp(escapePattern, 'g');
                const regex = new RegExp(config.pattern.replace(escapeRegex, '\\\\$&'), 'gi');
                let match;
                while ((match = regex.exec(processingContent)) !== null && totalIterations < maxIterations) {
                  totalIterations++;
                  const fullMatch = match[0];
                  const value = fullMatch;
                  const startIndex = match.index;
                  const length = value.length;
                  matches.push({
                    value,
                    fullMatch,
                    startIndex,
                    length
                  });
                }
              }
              
              console.log('üìà Found', matches.length, 'matches for:', fieldName);
              return matches;
            } catch (error) {
              console.error('‚ùå Error computing results for:', fieldName, error);
              console.error('Config:', config);
              console.error('Content length:', processingContent?.length || 0);
              
              // Return error result instead of crashing
              return [{ 
                error: 'Processing error: ' + error.message,
                value: 'Error',
                startIndex: 0,
                length: 0
              }];
            }
          };
          
          if (type === 'COMPUTE_TEST_RESULTS') {
            try {
              console.log('WORKER: Received COMPUTE_TEST_RESULTS');
              const { fileContent, rules, excludePatterns, hierarchySettings } = data;
              
              // --- Define dependencies for computeTestResultsSync ---
              const filteredLines = fileContent.split('\\n');
              const columnMapping = hierarchySettings.columnMapping || null; // Passed from main thread
              
              // Compute columnPositions from columnMapping if available, otherwise use passed value
              let columnPositions = hierarchySettings.columnPositions; // Default to passed value
              if (columnMapping && columnMapping.spec && columnMapping.spec.boundaries && columnMapping.spec.boundaries.length > 0) {
                // Use column mapping boundaries (1-based inclusive) converted to 0-based inclusive
                columnPositions = columnMapping.spec.boundaries
                  .slice()
                  .sort((a, b) => a.start - b.start)
                  .map(b => ({
                    start: Math.max(0, (b.start ?? 1) - 1),
                    end: Math.max(0, (b.end ?? b.start) - 1),
                    isMerged: false
                  }));
              }
              
              // This is the local, worker-side version
              const isLineExcluded = (line) => {
                return excludePatterns.some(pattern => wouldLineBeExcluded(line, pattern));
              };
              // --- End dependencies ---
              
              const resultsByRuleId = {};
              console.log('WORKER: Computing test results for ' + rules.length + ' rules...');
              
              rules.forEach(rule => {
                const config = { ...rule, level: rule.level || 'primary' };
                const hierarchyContext = { 
                  mode: hierarchySettings.mode, 
                  identifier: hierarchySettings.identifier,
                  columnPositions: columnPositions,
                  columnMapping: columnMapping
                };
                
                // Call the computeTestResultsSync function we copied into the worker
                resultsByRuleId[rule.id] = computeTestResultsSync(
                  config, 
                  isLineExcluded, // Use worker's local function
                  hierarchyContext,
                  fileContent // Pass fileContent as parameter
                );
              });
              console.log('WORKER: Computation complete. Sending results back.');
              // Send back the computed results and the settings for the next step
              self.postMessage({ 
                type: 'TEST_RESULTS_COMPLETE', 
                results: resultsByRuleId, 
                hierarchySettings: hierarchySettings, // Pass settings through
                excludePatterns: excludePatterns // Pass exclusions through
              });
              
            } catch (error) {
              console.error('WORKER: Error in COMPUTE_TEST_RESULTS', error);
              self.postMessage({ type: 'TEST_RESULTS_COMPLETE', results: {}, error: error.message });
            }
          }
          
          if (type === 'PROCESS_HIERARCHY') {
            const { fileContent, rules, settings, excludePatterns } = data;

            // Validation
            if (!fileContent || !rules || !Array.isArray(rules)) {
              self.postMessage({ type: 'HIERARCHY_COMPLETE', data: [] });
              return;
            }

            try {
              console.log('üîÑ Starting new Anchor & Group hierarchy processing...');
              const startTime = performance.now();

              // Compute columnPositions from columnMapping if available, otherwise use passed value
              const columnMapping = settings.columnMapping || null;
              let columnPositions = settings.columnPositions; // Default to passed value
              if (columnMapping && columnMapping.spec && columnMapping.spec.boundaries && columnMapping.spec.boundaries.length > 0) {
                // Use column mapping boundaries (1-based inclusive) converted to 0-based inclusive
                columnPositions = columnMapping.spec.boundaries
                  .slice()
                  .sort((a, b) => a.start - b.start)
                  .map(b => ({
                    start: Math.max(0, (b.start ?? 1) - 1),
                    end: Math.max(0, (b.end ?? b.start) - 1),
                    isMerged: false
                  }));
              }
              
              // Update settings with computed columnPositions
              const updatedSettings = {
                ...settings,
                columnPositions: columnPositions,
                columnMapping: columnMapping
              };

              const flattenedData = processHierarchicalData(fileContent, rules, updatedSettings, excludePatterns);

              console.log('‚úÖ Anchor & Group hierarchy processing complete: ' + flattenedData.length + ' rows (' + (performance.now() - startTime) + 'ms total)');

              // Send processed data
              if (flattenedData.length > 0) {
                const chunkSize = 1000;
                if (flattenedData.length > chunkSize) {
                  for (let i = 0; i < flattenedData.length; i += chunkSize) {
                    self.postMessage({
                      type: 'HIERARCHY_CHUNK',
                      data: flattenedData.slice(i, i + chunkSize),
                      progress: Math.round((i / flattenedData.length) * 100)
                    });
                  }
                }
                self.postMessage({ type: 'HIERARCHY_COMPLETE', data: flattenedData });
              } else {
                self.postMessage({ type: 'HIERARCHY_COMPLETE', data: [] });
              }
            } catch (error) {
              console.error('Hierarchy processing error:', error);
              self.postMessage({ type: 'HIERARCHY_COMPLETE', data: [], error: error.message });
            }
            
            // New Anchor & Group processing function (Debug Version)
            function processHierarchicalData(text, rules, settings, excludePatterns) {
                console.log("--- WORKER: STARTING HIERARCHICAL PROCESSING ---");
                console.log("Received Settings:", settings);
                console.log(\`Received \${rules.length} rules total.\`);
                
                // --- Rule Filtering ---
                const primaryRules = rules.filter(r => r.level !== 'append');
                const appendRules = rules.filter(r => r.level === 'append');
                
                console.log(\`Found \${primaryRules.length} Primary Rules:\`, JSON.parse(JSON.stringify(primaryRules)));
                console.log(\`Found \${appendRules.length} Append Rules:\`, JSON.parse(JSON.stringify(appendRules)));

                const extractValue = (line, rule, columnPositions, columnMapping) => { // <-- Added columnMapping parameter
                    if (!rule || !rule.pattern) {
                        return null;
                    }

                    const ruleType = (rule.ruleType || rule.type || '').toUpperCase();

                    if (ruleType === 'POSITION' && rule.pattern.startsWith('column:')) {
                        const columnSpec = rule.pattern.split(':')[1].trim();

                        if (columnSpec.includes('-')) {
                            // Handles ranges like "column:1-8"
                            const [start, end] = columnSpec.split('-').map(n => parseInt(n.trim()));

                            if (isNaN(start) || isNaN(end)) { return null; }

                            if (line.length < start) { return null; } // Check start boundary

                            const substringResult = line.substring(start - 1, Math.min(end, line.length));
                            const trimmedResult = substringResult.trim();

                            return trimmedResult;
                        } else {
                            // Handles single columns - support both numeric (column:1) and named (column:"Inv Date") references
                            const columnNum = resolveColumnIndex(columnSpec, columnMapping);
                            if (columnNum === null) return null;

                            let rawValue = null;
                            let trimmedValue = null;

                            // PREFER fixed-width logic if columnPositions map is available
                            if (columnPositions && columnPositions.length >= columnNum) {
                                const pos = columnPositions[columnNum - 1];
                                if (line.length > pos.start) {
                                    rawValue = line.substring(pos.start, pos.end + 1);
                                    trimmedValue = rawValue.trim();
                                }
                            } else {
                                // FALLBACK to split logic if no map is available
                                const colIndex = columnNum - 1;
                                const columns = line.split(/\s{2,}/);
                                if (columns.length > colIndex) {
                                    rawValue = columns[colIndex];
                                    trimmedValue = rawValue.trim();
                                }
                            }

                            if (trimmedValue !== null) {
                                return trimmedValue;
                            }
                        }
                    } else if (ruleType === 'REGEX' || ruleType === 'APPEND' || ruleType === 'PATTERN') {
                        // Handles both REGEX and APPEND rules
                        try {
                            const match = line.match(new RegExp(rule.pattern));
                            if (match) {
                                const extracted = (match[1] !== undefined ? match[1] : match[0]).trim();
                                return extracted;
                            }
                        } catch (e) {
                            console.error('Invalid regex in worker:', rule.pattern, e);
                        }
                    }

                    return null;
                };

                // --- Line Exclusion Function ---
                const isLineExcluded = (line) => {
                  const normalize = (str) => {
                    return str.replace(/[0-9-=]/g, ' ').toLowerCase().replace(/\s+/g, ' ').trim();
                  };

                  return excludePatterns.some(pattern => {
                    if (pattern.isFuzzy) {
                      // Fuzzy matching: normalize out variables like page numbers/dates
                      return normalize(line).includes(normalize(pattern.pattern));
                    } else if (pattern.isRegex) {
                      try {
                        return new RegExp(pattern.pattern, 'i').test(line);
                      } catch {
                        return false;
                      }
                    } else {
                      return line.toLowerCase().includes(pattern.pattern.toLowerCase());
                    }
                  });
                };

                // --- Grouping Pass ---
                const lines = text.split('\\n');
                const recordGroups = [];
                let currentGroup = null;
                const primaryLineRegex = new RegExp(settings.primaryLineIdentifier);
                
                lines.forEach(line => {
                    if (isLineExcluded(line)) return;  // Skip excluded lines entirely

                    if (primaryLineRegex.test(line)) {
                        if (currentGroup) recordGroups.push(currentGroup);
                        currentGroup = { primaryLine: line, subLines: [] };
                    } else if (currentGroup && line.trim() !== '') {
                        currentGroup.subLines.push(line);
                    }
                });
                if (currentGroup) recordGroups.push(currentGroup);
                console.log(\`Grouping complete. Found \${recordGroups.length} record groups.\`);

                // --- Flattening Pass ---
                const flattenedData = recordGroups.map((group, groupIndex) => {
                    let record = {};

                    if (groupIndex < 2) { // Log details for the first two groups only
                        console.log(\`\n--- Processing Group #\${groupIndex} ---\`);
                        console.log("Primary Line:", group.primaryLine);
                    }

                    // Apply primary rules
                    primaryRules.forEach(rule => {
                        const value = extractValue(group.primaryLine, rule, settings.columnPositions, settings.columnMapping);
                        if (value !== null && value !== '') {
                            record[rule.fieldName] = value;
                            if (groupIndex < 2) {
                                console.log(\`SUCCESS: Rule '\${rule.fieldName}' (\${rule.type}) extracted -> "\${value}"\`);
                            }
                        } else {
                             // Log failures for the first two groups
                            if (groupIndex < 2 && rule.ruleType === 'POSITION') {
                                console.warn(\`FAILURE: Positional Rule '\${rule.fieldName}' (pattern: \${rule.pattern}) extracted NOTHING.\`);
                            }
                        }
                    });
                    
                    // --- START DUAL-STRATEGY APPEND LOGIC ---

                    // 1. Split rules based on the required logic

                    const positionalAppendRules = appendRules.filter(r => r.ruleType === 'POSITION');

                    const patternAppendRules = appendRules.filter(r => r.ruleType !== 'POSITION');

                    // 2. Process POSITIONAL appends (Alignment-Safe, Single-Pass)

                    // We must initialize strings for alignment

                    positionalAppendRules.forEach(rule => {

                        record[rule.fieldName] = '';

                    });

                    group.subLines.forEach((subLine, subIndex) => {

                        positionalAppendRules.forEach(rule => {

                            const value = extractValue(subLine, rule, settings.columnPositions, settings.columnMapping);

                            let valueToAppend;

                            if (value === null || value === '') {

                                const onEmptyAction = rule.onEmpty || 'null';

                                switch (onEmptyAction) {

                                    case 'na': valueToAppend = 'N/A'; break;

                                    case 'empty': valueToAppend = ''; break;

                                    case 'null':

                                    default: valueToAppend = ''; break;

                                }

                            } else {

                                valueToAppend = value;

                            }

                            if (subIndex > 0) {

                                record[rule.fieldName] += ', ';

                            }

                            record[rule.fieldName] += valueToAppend;

                        });

                    });

                    // 3. Process PATTERN/REGEX appends (Filtering, Original Fast Logic)

                    // This logic correctly *skips* non-matching lines.

                    group.subLines.forEach(subLine => {

                        patternAppendRules.forEach(rule => {

                            const value = extractValue(subLine, rule, settings.columnPositions, settings.columnMapping);

                            if (value !== null) { // This "if" is intentional and correct for regex

                                let valueToAppend = value;

                                if (value === '') {

                                    switch (rule.onEmpty) {

                                        case 'na': valueToAppend = 'N/A'; break;

                                        case 'empty': valueToAppend = ''; break;

                                        case 'null':

                                        default:

                                            // Do not append if onEmpty is 'null'

                                            return;

                                    }

                                }

                                // MERGE LOGIC (from your original fast file)

                                if (record[rule.fieldName]) {

                                    record[rule.fieldName] += \`, \${valueToAppend}\`;

                                } else {

                                    record[rule.fieldName] = valueToAppend;

                                }

                            }

                        });

                    });

                    // --- END DUAL-STRATEGY APPEND LOGIC ---
                    
                    return record;
                });
                
                console.log("\\n--- WORKER: FINISHED ---");
                console.log("First record processed:", flattenedData[0]);
                
                return flattenedData;
            }
          }
        };
      `;
      
      const blob = new Blob([workerCode], { type: 'application/javascript' });
      return new Worker(URL.createObjectURL(blob));
    };



    // Helper function to escape HTML (performance optimized)
    const escapeHtml = (text) => {
      if (typeof text !== 'string') return '';
      return text
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#39;');
    };

    // Rule types and configurations
    const RULE_TYPES = {
      PATTERN: { 
        name: 'Pattern Match', 
        icon: 'üîç', 
        description: 'Extract using regex patterns',
        examples: ['Invoice Number: (\\w+)', '^(\\d{4})\\s+', 'Total: \\$([\\d,]+\\.\\d{2})']
      },
      POSITION: { 
        name: 'Position Based', 
        icon: 'üìç', 
        description: 'Extract from line/column positions',
        examples: ['column:1 (smart column 1)', 'column:2 (smart column 2)', 'column:"Inv Date" (by column name)', 'column:1-12 (fixed chars 1-12 for account)', 'column:13-42 (fixed chars 13-42 for description)', 'line:5']
      },
      SINGLE: { 
        name: 'Single Value', 
        icon: 'üìù', 
        description: 'Extract selected text exactly',
        examples: ['Selected text as-is']
      }
    };

    const DATA_TYPES = {
      TEXT: { name: 'Text', icon: 'üìù' },
      NUMBER: { name: 'Number', icon: 'üî¢' },
      CURRENCY: { name: 'Currency', icon: 'üí∞' },
      DATE: { name: 'Date', icon: 'üìÖ' }
    };

    // Custom virtualization implementation for optimal performance
    
    // Custom FixedSizeList implementation with forwardRef
    const CustomFixedSizeList = React.forwardRef(({ height, itemCount, itemSize, children, overscanCount = 5, itemData, ...props }, ref) => {
      const [scrollTop, setScrollTop] = useState(0);
      const containerRef = useRef(null);
      
      // Forward ref to container
      React.useImperativeHandle(ref, () => containerRef.current);
      
      // Calculate visible range
      const startIndex = Math.max(0, Math.floor(scrollTop / itemSize) - overscanCount);
      const endIndex = Math.min(itemCount, Math.ceil((scrollTop + height) / itemSize) + overscanCount);
      
      // Handle scroll
      const handleScroll = useCallback((e) => {
        setScrollTop(e.target.scrollTop);
      }, []);
      
      // Render visible items - children should be a function
      const visibleItems = [];
      if (typeof children === 'function') {
        for (let index = startIndex; index < endIndex; index++) {
          const style = {
            position: 'absolute',
            top: index * itemSize,
            left: 0,
            right: 0,
            height: itemSize,
          };
          visibleItems.push(children({ index, style, key: index, data: itemData }));
        }
      } else {
        console.error('CustomFixedSizeList: children must be a function that returns a React element. Got:', typeof children);
      }
      
      return (
        <div
          ref={containerRef}
          style={{
            height,
            overflow: 'auto',
            position: 'relative',
          }}
          onScroll={handleScroll}
          {...props}
        >
          {/* Total height container */}
          <div style={{ height: itemCount * itemSize, position: 'relative' }}>
            {visibleItems}
          </div>
        </div>
      );
    });
    
    // Use our custom implementation
    const List = CustomFixedSizeList;

    // Column Mapping Inspector utilities
    const UNDERLINE_CHARS = /[-‚Äì‚Äî_]/;
    const SPACE_GAP = 2;

    function detectSmartColumnsFromUnderline(lines) {
      // Find a line that looks like a dashed underline: e.g. "----  -----  ----"
      const underlineLine = lines.find(l => {
        const trimmed = l.trim();
        if (!trimmed) return false;
        const ratio = trimmed.split('').filter(ch => UNDERLINE_CHARS.test(ch)).length / trimmed.length;
        return ratio > 0.5 && /-/.test(trimmed);
      });

      if (!underlineLine) return null;

      // Contiguous runs of dash-like chars -> boundaries by edges between runs and spaces.
      const runs = [];
      let inRun = false, runStart = 0;

      for (let i = 0; i < underlineLine.length; i++) {
        const ch = underlineLine[i];
        if (UNDERLINE_CHARS.test(ch)) {
          if (!inRun) { inRun = true; runStart = i; }
        } else {
          if (inRun) { runs.push({start: runStart + 1, end: i }); inRun = false; }
        }
      }

      if (inRun) runs.push({ start: runStart + 1, end: underlineLine.length });

      // Convert runs to column boundaries; ensure increasing, at least 1 char width.
      const boundaries = runs.map((r, idx) => ({
        id: `col_${idx}_${r.start}_${r.end}`,
        start: r.start,
        end: Math.max(r.start, r.end),
      }));

      return boundaries.length ? boundaries : null;
    }

    function detectSmartColumnsFromSpacing(lines) {
      // Heuristic: find positions where many lines have >= 2 consecutive spaces; cluster them.
      // Use reduce instead of spread operator to avoid stack overflow with large arrays
      const maxLen = lines.reduce((max, line) => Math.max(max, line.length), 0);
      const gapScore = new Array(maxLen).fill(0);

      lines.forEach(l => {
        let run = 0;
        for (let i = 0; i < l.length; i++) {
          const isSpace = l[i] === ' ';
          run = isSpace ? run + 1 : 0;
          if (run >= SPACE_GAP) gapScore[i] += 1;
        }
      });

      // Threshold: positions that are gaps in majority of lines considered separators.
      const threshold = Math.max(3, Math.floor(lines.length * 0.5));
      const seps = [];

      let i = 0;
      while (i < gapScore.length) {
        if (gapScore[i] >= threshold) {
          // collapse contiguous high-score region
          const start = i;
          while (i < gapScore.length && gapScore[i] >= threshold) i++;
          const end = i - 1;
          // separator index ~ midpoint
          seps.push(Math.round((start + end) / 2) + 1); // to 1-based
        }
        i++;
      }

      // Build boundaries between separators
      const starts = [1, ...seps.map(s => s + 1)];
      const ends = [...seps, maxLen];

      const boundaries = starts.map((s, idx) => ({
        id: `col_${idx}_${s}_${ends[idx]}`,
        start: s,
        end: Math.max(s, ends[idx]),
      })).filter(b => b.end >= b.start);

      return boundaries;
    }

    function detectSmartSpec(lines, sampleWindow = 30) {
      const window = lines.slice(0, sampleWindow);
      const underline = detectSmartColumnsFromUnderline(window);

      if (underline && underline.length) {
        return { source: 'underline', boundaries: underline };
      }

      return { source: 'spacing', boundaries: detectSmartColumnsFromSpacing(window) };
    }

    function measureMonospaceCharWidth(container) {
      // Create hidden probe with same font as Document View
      const probe = document.createElement('span');
      probe.style.visibility = 'hidden';
      probe.style.position = 'absolute';
      probe.style.whiteSpace = 'pre';
      probe.textContent = 'MMMMMMMMMM'; // 10 chars
      container.appendChild(probe);
      const width = probe.getBoundingClientRect().width / 10;
      container.removeChild(probe);
      return width || 8;
    }

    function normalizeBoundaries(boundaries) {
      const sorted = [...boundaries].sort((a,b) => a.start - b.start);
      // Optionally clamp gaps/overlaps; for now we allow 1-char minimum width.
      return sorted;
    }

    function normalizeAndInsert(arr, b) {
      return normalizeBoundaries([...arr, b]);
    }

    function sliceLineByBoundaries(line, boundaries) {
      return boundaries.map(b => safeSlice(line, b.start, b.end));
    }

    function safeSlice(line, start, end) {
      // start/end are 1-based inclusive
      const s = Math.max(0, start - 1);
      const e = Math.min(line.length, end);
      return line.slice(s, e).trimEnd();
    }

    // Helper to find the actual scrolling element (might be nested)
    function findScrollingElement(element) {
      if (!element) return null;
      if (element.scrollWidth > element.clientWidth && element.scrollLeft !== undefined) {
        return element;
      }
      for (let child of element.children) {
        const found = findScrollingElement(child);
        if (found) return found;
      }
      return element; // Fallback to the element itself
    }

    // FieldChip component - extracted outside to prevent re-creation on parent renders
    const FieldChip = ({ column, columnMappings, setColumnMappings }) => {
      const mapping = columnMappings.find(m => m.columnId === column.id);
      const [val, setVal] = useState(mapping?.fieldName ?? '');

      useEffect(() => {
        setVal(mapping?.fieldName ?? '');
      }, [mapping?.fieldName]);

      return (
        <div style={{
          position: 'absolute', 
          top: 28,
          left: 6, 
          right: 6,
          display: 'flex', 
          gap: 6, 
          alignItems: 'center',
          pointerEvents: 'auto',
          zIndex: 12,
        }}>
          <input
            aria-label={`Field for column ${column.id}`}
            value={val}
            onChange={(e) => setVal(e.target.value)}
            onBlur={() => {
              const idx = columnMappings.findIndex(m => m.columnId === column.id);
              const newMappings = [...columnMappings];
              if (idx >= 0) {
                if (val.trim()) {
                  newMappings[idx].fieldName = val.trim();
                } else {
                  newMappings.splice(idx, 1);
                }
              } else if (val.trim()) {
                newMappings.push({ columnId: column.id, fieldName: val.trim() });
              }
              setColumnMappings(newMappings);
            }}
            placeholder="Field name"
            style={{ 
              width: '100%', 
              fontSize: 12, 
              padding: '2px 4px',
              pointerEvents: 'auto',
              position: 'relative',
              zIndex: 12,
            }}
          />
        </div>
      );
    };

    // ColumnOverlay component - extracted outside to prevent re-creation on parent renders
    const ColumnOverlay = ({ 
      containerId, 
      sampleHeaderLine,
      columnMappingEnabled,
      columnMappingSpec,
      setColumnMappingSpec,
      columnMappings,
      setColumnMappings,
      selectedHandleId,
      setSelectedHandleId,
      charWidthPx,
      setCharWidthPx,
      filteredLines
    }) => {
      const containerRef = useRef(null);
      const [drag, setDrag] = useState({ columnId: null, edge: null, startX: null, orig: null, startCharPos: null });
      const [containerReady, setContainerReady] = useState(false);
      const [contentWidth, setContentWidth] = useState(0);
      const [scrollLeft, setScrollLeft] = useState(0);
      const [containerRect, setContainerRect] = useState(null);
      const dragRef = useRef(drag);
      const columnMappingSpecRef = useRef(columnMappingSpec);
      const charWidthPxRef = useRef(charWidthPx);
      const dragListenersActiveRef = useRef(false);
      
      useEffect(() => {
        dragRef.current = drag;
      }, [drag]);
      useEffect(() => {
        columnMappingSpecRef.current = columnMappingSpec;
      }, [columnMappingSpec]);
      useEffect(() => {
        charWidthPxRef.current = charWidthPx;
      }, [charWidthPx]);

      useEffect(() => {
        if (!columnMappingEnabled) {
          containerRef.current = null;
          setContainerReady(false);
          return;
        }
        
        const el = document.getElementById(containerId);
        if (!el) {
          setContainerReady(false);
          setTimeout(() => {
            const retryEl = document.getElementById(containerId);
            if (retryEl) {
              containerRef.current = retryEl;
              const measuredWidth = measureMonospaceCharWidth(retryEl);
              setCharWidthPx(measuredWidth);
              setContainerReady(true);
            }
          }, 100);
          return;
        }
        
        containerRef.current = el;
        const measuredWidth = measureMonospaceCharWidth(el);
        setCharWidthPx(measuredWidth);
        
        const calculateWidth = () => {
          const maxLineLength = filteredLines.reduce((max, line) => Math.max(max, line.length), 0);
          return maxLineLength * measuredWidth;
        };
        
        const calculatedContentWidth = calculateWidth();
        setContentWidth(calculatedContentWidth);
        
        setContainerReady(true);

        if (!columnMappingSpec && filteredLines.length > 0) {
          const lines = filteredLines.slice(0, 200);
          const detectedSpec = detectSmartSpec(lines);
          if (detectedSpec && detectedSpec.boundaries && detectedSpec.boundaries.length > 0) {
            setColumnMappingSpec(detectedSpec);
          }
        }
        
        const recalcTimeout = setTimeout(() => {
          const newWidth = calculateWidth();
          if (newWidth !== calculatedContentWidth) {
            setContentWidth(newWidth);
          }
        }, 100);
        
        return () => clearTimeout(recalcTimeout);
      }, [columnMappingEnabled, containerId, filteredLines, columnMappingSpec, setColumnMappingSpec, setCharWidthPx]);

      useEffect(() => {
        if (!columnMappingEnabled || !containerRef.current) return;
        
        let rafId = null;
        const el = containerRef.current;
        
        const findScrollingElements = (element) => {
          const elements = [];
          if (element.scrollWidth > element.clientWidth) {
            elements.push(element);
          }
          for (let child of element.children) {
            elements.push(...findScrollingElements(child));
          }
          return elements;
        };
        
        const scrollingElements = [el, ...findScrollingElements(el)];
        
        const updateScrollAndRect = () => {
          let maxScrollLeft = 0;
          for (const scrollEl of scrollingElements) {
            const sl = scrollEl.scrollLeft || 0;
            if (sl > maxScrollLeft) {
              maxScrollLeft = sl;
            }
          }
          
          setScrollLeft(prev => prev !== maxScrollLeft ? maxScrollLeft : prev);
          
          if (el) {
            const rect = el.getBoundingClientRect();
            setContainerRect(prev => {
              if (prev && 
                  prev.top === rect.top && 
                  prev.left === rect.left && 
                  prev.width === rect.width && 
                  prev.height === rect.height) {
                return prev;
              }
              return {
                top: rect.top,
                left: rect.left,
                width: rect.width,
                height: rect.height,
              };
            });
          }
          
          rafId = null;
        };
        
        const handleScroll = () => {
          if (!rafId) {
            rafId = requestAnimationFrame(updateScrollAndRect);
          }
        };
        
        const handleResize = () => {
          if (!rafId) {
            rafId = requestAnimationFrame(updateScrollAndRect);
          }
        };
        
        scrollingElements.forEach(scrollEl => {
          scrollEl.addEventListener('scroll', handleScroll, { passive: true });
        });
        window.addEventListener('resize', handleResize);
        window.addEventListener('scroll', handleResize, true);
        
        updateScrollAndRect();
        
        return () => {
          if (rafId) cancelAnimationFrame(rafId);
          scrollingElements.forEach(scrollEl => {
            scrollEl.removeEventListener('scroll', handleScroll);
          });
          window.removeEventListener('resize', handleResize);
          window.removeEventListener('scroll', handleResize, true);
        };
      }, [columnMappingEnabled, containerReady]);

      useEffect(() => {
        const onKey = (e) => {
          if (!columnMappingEnabled) return;
          const delta = (e.shiftKey ? 5 : 1) * ((e.key === 'ArrowLeft') ? -1 : (e.key === 'ArrowRight') ? 1 : 0);
          if (!delta) return;
          e.preventDefault();
          const id = selectedHandleId;
          if (!id) return;
          const [colId, edge] = id.split(':');
          const spec = columnMappingSpec;
          if (!spec) return;
          const target = spec.boundaries.find(b => b.id === colId);
          if (!target) return;
          const newBoundaries = spec.boundaries.map(b => {
            if (b.id !== colId) return b;
            const next = { ...b };
            next[edge] = Math.max(1, next[edge] + delta);
            if (next.start > next.end) [next.start, next.end] = [next.end, next.start];
            return next;
          });
          setColumnMappingSpec({ ...spec, boundaries: normalizeBoundaries(newBoundaries) });
        };
        window.addEventListener('keydown', onKey);
        return () => window.removeEventListener('keydown', onKey);
      }, [columnMappingEnabled, selectedHandleId, columnMappingSpec, setColumnMappingSpec]);

      const setupDragListeners = (dragState) => {
        if (dragListenersActiveRef.current) {
          return;
        }
        dragListenersActiveRef.current = true;
        
        const handlePointerMove = (e) => {
          const currentDrag = dragRef.current;
          const currentSpec = columnMappingSpecRef.current;
          const currentCharWidth = charWidthPxRef.current;
          
          if (!currentDrag.columnId || !currentSpec || currentDrag.startX == null || !currentDrag.edge || currentDrag.startCharPos == null) {
            return;
          }
          
          const dx = e.clientX - currentDrag.startX;
          const deltaChars = Math.round(dx / currentCharWidth);
          
          const newBoundaries = currentSpec.boundaries.map(b => {
            if (b.id !== currentDrag.columnId) return b;
            const next = { ...b };
            const newPos = Math.max(1, currentDrag.startCharPos + deltaChars);
            next[currentDrag.edge] = newPos;
            if (next.start > next.end) {
              [next.start, next.end] = [next.end, next.start];
            }
            return next;
          });
          
          setColumnMappingSpec({ ...currentSpec, boundaries: normalizeBoundaries(newBoundaries) });
        };
        
        const handleMouseMove = (e) => {
          handlePointerMove(e);
        };
        
        const handlePointerUp = (e) => {
          if (e.target.hasPointerCapture && e.target.hasPointerCapture(e.pointerId)) {
            e.target.releasePointerCapture(e.pointerId);
          }
          setDrag({ columnId: null, edge: null, startX: null, orig: null, startCharPos: null });
          document.removeEventListener('pointermove', handlePointerMove);
          document.removeEventListener('pointerup', handlePointerUp);
          document.removeEventListener('mousemove', handleMouseMove);
          document.removeEventListener('mouseup', handleMouseUp);
          dragListenersActiveRef.current = false;
        };
        
        const handleMouseUp = (e) => {
          handlePointerUp(e);
        };
        
        document.addEventListener('pointermove', handlePointerMove, { passive: false });
        document.addEventListener('pointerup', handlePointerUp, { passive: false });
        document.addEventListener('mousemove', handleMouseMove, { passive: false });
        document.addEventListener('mouseup', handleMouseUp, { passive: false });
      };

      const onPointerDown = (e, col, edge) => {
        e.preventDefault();
        e.stopPropagation();
        
        const target = e.target;
        if (target.setPointerCapture) {
          target.setPointerCapture(e.pointerId);
        }
        
        const dragState = { 
          columnId: col.id, 
          edge, 
          startX: e.clientX, 
          orig: { ...col },
          startCharPos: col[edge]
        };
        
        dragRef.current = dragState;
        setupDragListeners(dragState);
        
        setDrag(dragState);
        setSelectedHandleId(`${col.id}:${edge}`);
      };

      const px = (colCharIndex) => (colCharIndex - 1) * charWidthPx;

      const onDoubleClick = (e) => {
        const el = containerRef.current;
        if (!el) return;
        
        const scrollingEl = findScrollingElement(el);
        const rect = el.getBoundingClientRect();
        
        const currentScrollLeft = scrollingEl ? (scrollingEl.scrollLeft || 0) : 0;
        const x = e.clientX - rect.left + currentScrollLeft;
        const atChar = Math.max(1, Math.round(x / charWidthPx) + 1);
        const id = `col_manual_${Date.now()}`;
        const newBoundary = { id, start: atChar, end: atChar + 1 };
        
        if (columnMappingSpec && columnMappingSpec.boundaries) {
          setColumnMappingSpec({
            ...columnMappingSpec,
            boundaries: normalizeAndInsert(columnMappingSpec.boundaries, newBoundary)
          });
        } else {
          setColumnMappingSpec({
            source: 'manual',
            boundaries: [newBoundary]
          });
        }
      };

      const onContextMenu = (e) => {
        if (e.target.closest('button[aria-label^="Delete column"]')) {
          return;
        }
        
        e.preventDefault();
        
        const el = containerRef.current;
        if (!el || !columnMappingSpec || !columnMappingSpec.boundaries) return;
        
        const rect = el.getBoundingClientRect();
        const scrollingEl = findScrollingElement(el);
        const currentScrollLeft = scrollingEl ? (scrollingEl.scrollLeft || 0) : 0;
        const x = e.clientX - rect.left + currentScrollLeft;
        const charPos = Math.max(1, Math.round(x / charWidthPx) + 1);
        
        const clickedColumn = columnMappingSpec.boundaries.find(b => 
          charPos >= b.start && charPos <= b.end
        );
        
        if (clickedColumn) {
          setColumnMappingSpec({
            ...columnMappingSpec,
            boundaries: columnMappingSpec.boundaries.filter(b => b.id !== clickedColumn.id)
          });
          setColumnMappings(columnMappings.filter(m => m.columnId !== clickedColumn.id));
        }
      };

      if (!columnMappingEnabled) {
        return null;
      }
      
      if (!containerReady || !containerRef.current) {
        return <div style={{ position: 'absolute', inset: 0, pointerEvents: 'none' }} />;
      }
      
      if (!columnMappingSpec || !columnMappingSpec.boundaries || columnMappingSpec.boundaries.length === 0) {
        return (
          <div 
            style={{ position: 'absolute', inset: 0, pointerEvents: 'auto', display: 'flex', alignItems: 'center', justifyContent: 'center', zIndex: 1000 }}
            onDoubleClick={onDoubleClick}
          >
            <div style={{ background: 'rgba(255, 255, 255, 0.9)', padding: '12px 24px', borderRadius: '8px', border: '2px solid rgba(0, 128, 255, 0.6)', pointerEvents: 'auto' }}>
              <div style={{ fontWeight: 'bold', color: '#0066cc', marginBottom: '4px' }}>üß≠ Column Mapping Active</div>
              <div style={{ fontSize: '12px', color: '#666' }}>
                {filteredLines.length === 0 
                  ? 'Load a document to detect columns'
                  : 'No columns detected. Double-click anywhere in the document to add column boundaries manually.'}
              </div>
            </div>
          </div>
        );
      }

      const lineHeight = 20;
      const fullDocumentHeight = filteredLines.length * lineHeight;
      
      const overlayStyle = {
        position: 'absolute',
        top: 0,
        left: -scrollLeft,
        width: contentWidth || '100%',
        height: fullDocumentHeight,
        minHeight: '100%',
        pointerEvents: 'none',
        zIndex: 10,
      };
      
      const containerWidth = containerRect?.width || 0;
      const containerHeight = containerRect?.height || 0;
      const wrapperStyle = containerWidth > 0 && containerHeight > 0 ? {
        position: 'absolute',
        top: 0,
        left: 0,
        width: `${containerWidth}px`,
        height: `${containerHeight}px`,
        overflow: 'hidden',
        pointerEvents: 'none',
        zIndex: 10,
        boxSizing: 'border-box',
        clipPath: `inset(0 0 0 0)`,
      } : {};

      const handleBarHeight = 24;
      
      return (
        <>
          {containerRect && containerWidth > 0 && (
            <div
              style={{
                position: 'absolute',
                top: 0,
                left: 0,
                width: `${containerWidth}px`,
                height: handleBarHeight,
                zIndex: 11,
                pointerEvents: 'none',
                background: 'rgba(0, 128, 255, 0.05)',
                borderBottom: '2px solid rgba(0, 128, 255, 0.3)',
                overflow: 'hidden',
                clipPath: `inset(0 0 0 0)`,
              }}
            >
              {columnMappingSpec.boundaries.map((b) => (
                <React.Fragment key={`top-${b.id}`}>
                  <button
                    className="column-overlay"
                    onClick={(e) => {
                      e.preventDefault();
                      e.stopPropagation();
                      if (columnMappingSpec && columnMappingSpec.boundaries) {
                        setColumnMappingSpec({
                          ...columnMappingSpec,
                          boundaries: columnMappingSpec.boundaries.filter(boundary => boundary.id !== b.id)
                        });
                        setColumnMappings(columnMappings.filter(m => m.columnId !== b.id));
                      }
                    }}
                    style={{
                      position: 'absolute',
                      left: px(b.start) - scrollLeft + (px(b.end + 1) - px(b.start)) / 2 - 8,
                      top: 2,
                      width: '16px',
                      height: '16px',
                      cursor: 'pointer',
                      background: 'rgba(239, 68, 68, 0.9)',
                      border: '1px solid rgba(220, 38, 38, 1)',
                      borderRadius: '3px',
                      display: 'flex',
                      alignItems: 'center',
                      justifyContent: 'center',
                      pointerEvents: 'auto',
                      fontSize: '12px',
                      color: 'white',
                      fontWeight: 'bold',
                      lineHeight: 1,
                      padding: 0,
                      zIndex: 12,
                    }}
                    title="Delete column (or right-click column)"
                    aria-label={`Delete column ${b.id}`}
                  >
                    √ó
                  </button>
                  {(['start','end']).map(edge => (
                    <div
                      key={`top-${b.id}-${edge}`}
                      role="slider"
                      aria-valuemin={1}
                      aria-valuenow={edge === 'start' ? b.start : b.end}
                      tabIndex={0}
                      onPointerDown={(e) => onPointerDown(e, b, edge)}
                      onMouseDown={(e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        const dragState = { 
                          columnId: b.id, 
                          edge, 
                          startX: e.clientX, 
                          orig: { ...b },
                          startCharPos: b[edge]
                        };
                        dragRef.current = dragState;
                        setupDragListeners(dragState);
                        setDrag(dragState);
                        setSelectedHandleId(`${b.id}:${edge}`);
                      }}
                      style={{
                        position: 'absolute',
                        left: px(b[edge]) - scrollLeft - (edge === 'start' ? 4 : -4),
                        top: 0,
                        width: '12px',
                        height: handleBarHeight,
                        cursor: 'ew-resize',
                        background: selectedHandleId === `${b.id}:${edge}` 
                          ? 'rgba(0, 128, 255, 0.4)' 
                          : 'rgba(0, 128, 255, 0.25)',
                        border: '1px solid rgba(0, 128, 255, 0.6)',
                        borderRadius: '2px',
                        display: 'flex',
                        alignItems: 'center',
                        justifyContent: 'center',
                        pointerEvents: 'auto',
                      }}
                      title={`Drag to adjust ${edge === 'start' ? 'left' : 'right'} boundary`}
                    >
                      <div style={{
                        width: '2px',
                        height: '12px',
                        background: 'rgba(255, 255, 255, 0.9)',
                        borderRadius: '1px',
                        pointerEvents: 'none',
                      }} />
                    </div>
                  ))}
                </React.Fragment>
              ))}
            </div>
          )}
          
          {containerRect && containerWidth > 0 && containerHeight > 0 && (
            <div style={wrapperStyle}>
              <div
                className="column-overlay"
                style={overlayStyle}
                onContextMenu={onContextMenu}
              >
            {columnMappingSpec.boundaries.map((b) => (
              <div 
                key={b.id} 
                aria-label={`column-${b.id}`}
                style={{
                  position: 'absolute',
                  left: px(b.start),
                  width: px(b.end + 1) - px(b.start),
                  top: 0, bottom: 0,
                  background: 'rgba(0, 128, 255, 0.06)',
                  borderLeft: '1px solid rgba(0, 128, 255, 0.6)',
                  borderRight: '1px solid rgba(0, 128, 255, 0.6)',
                  pointerEvents: 'none',
                }}
              >
                {(['start','end']).map(edge => (
                  <div
                    key={edge}
                    role="slider"
                    aria-valuemin={1}
                    aria-valuenow={edge === 'start' ? b.start : b.end}
                    tabIndex={0}
                    onPointerDown={(e) => onPointerDown(e, b, edge)}
                    onMouseDown={(e) => {
                      e.preventDefault();
                      e.stopPropagation();
                      const dragState = { 
                        columnId: b.id, 
                        edge, 
                        startX: e.clientX, 
                        orig: { ...b },
                        startCharPos: b[edge]
                      };
                      dragRef.current = dragState;
                      setupDragListeners(dragState);
                      setDrag(dragState);
                      setSelectedHandleId(`${b.id}:${edge}`);
                    }}
                    style={{
                      position: 'absolute',
                      [edge === 'start' ? 'left' : 'right']: '-4px',
                      top: handleBarHeight,
                      width: '8px',
                      bottom: 0,
                      cursor: 'ew-resize',
                      background: 'rgba(0, 128, 255, 0.1)',
                      pointerEvents: 'auto',
                    }}
                  />
                ))}
                <FieldChip column={b} columnMappings={columnMappings} setColumnMappings={setColumnMappings} />
              </div>
            ))}
            </div>
          </div>
          )}
        </>
      );
    };

    function AdvancedDocumentExtractor() {
      console.log('üöÄ AdvancedDocumentExtractor component starting...');

      try {
      
      // Core state
      const [fileContent, setFileContent] = useState('');
      const [fileName, setFileName] = useState('');
      const [selectionMode, setSelectionMode] = useState(false);
      const [currentSelection, setCurrentSelection] = useState(null);
      const [rules, setRules] = useState([]);
      const [extractedData, setExtractedData] = useState([]);
      const [showPreview, setShowPreview] = useState(true);
      
      const [worker, setWorker] = useState(null);
      const [isProcessing, setIsProcessing] = useState(false);
      const [isTestingPattern, setIsTestingPattern] = useState(false);
      const [processingProgress, setProcessingProgress] = useState(0);
      const [isUpdatingData, setIsUpdatingData] = useState(false);
      const [isAutoRefreshing, setIsAutoRefreshing] = useState(false);
      
      const [maxPreviewRows] = useState(1000);
      

      const tempExtractionDataRef = useRef([]);
      const lastProcessedContentRef = useRef('');
      

      const debouncedFileContent = useDebounce(fileContent, 300);
      const debouncedRules = useDebounce(rules, 200);
      
      // Rule builder state
      const [showRuleBuilder, setShowRuleBuilder] = useState(false);
      const [ruleType, setRuleType] = useState('SINGLE');
      const [fieldName, setFieldName] = useState('');
      const [dataType, setDataType] = useState('TEXT');
      const [pattern, setPattern] = useState('');
      const [ruleDescription, setRuleDescription] = useState('');
      const [testResults, setTestResults] = useState([]);
      const [selectedHierarchyLevel, setSelectedHierarchyLevel] = useState(null);
      const [scopeSubs, setScopeSubs] = useState(true); // Scope sub-rules to primary spans
      const [maxSpanLen, setMaxSpanLen] = useState(5); // Max lines to search for hierarchical data
      const [primaryLineIdentifier, setPrimaryLineIdentifier] = useState('^\\s*\\S+.*\\d{1,2}-\\d{1,2}-\\d{2}');
      const [showPrimaryHighlights, setShowPrimaryHighlights] = React.useState(true); // Default to true for immediate feedback
      const [showRegexAssistant, setShowRegexAssistant] = useState(false);
      const [regexInputText, setRegexInputText] = useState('');
      const [regexSuggestions, setRegexSuggestions] = useState([]);
      const [isGeneratingRegex, setIsGeneratingRegex] = useState(false);
      const [regexError, setRegexError] = useState(null);
      const [editingRule, setEditingRule] = useState(null);

      // Header exclusion state
      const [excludePatterns, setExcludePatterns] = useState([]);
      const [excludeMode, setExcludeMode] = useState(false);
      const [showExcludeOptions, setShowExcludeOptions] = useState(false);
      const [pendingExclusion, setPendingExclusion] = useState(null);
      const [appendScope, setAppendScope] = useState('proximity');
      const [appendOnEmpty, setAppendOnEmpty] = useState('null');

      // Templates state
      const [templates, setTemplates] = useState([]);
      const [isApplyingTemplate, setIsApplyingTemplate] = useState(false);

      // New states for highlights
      const [highlightsEnabled, setHighlightsEnabled] = useState(true);
      const [activeRuleId, setActiveRuleId] = useState(null);

      // Hierarchy builder state
      const [hierarchyMode, setHierarchyMode] = useState(false);
      const [hierarchyStack, setHierarchyStack] = useState([]);
      const [currentHierarchyLevel, setCurrentHierarchyLevel] = useState(null);
      const [showHierarchyView, setShowHierarchyView] = useState(false);
      const [hierarchyData, setHierarchyData] = useState([]);
      const [breakoutEnabled, setBreakoutEnabled] = useState(false);

      // Column Mapping Inspector state
      const [columnMappingEnabled, setColumnMappingEnabled] = useState(false);
      const [columnMappingSpec, setColumnMappingSpec] = useState(null);
      const [columnMappings, setColumnMappings] = useState([]);
      const [selectedHandleId, setSelectedHandleId] = useState(null);
      const [charWidthPx, setCharWidthPx] = useState(8);

      const fileInputRef = useRef(null);
      // --- TEMPORARY DEBUG CODE ---
      React.useEffect(() => {
        if (hierarchyMode && selectedHierarchyLevel) {
          console.log('--- HIERARCHY DEBUG ---');
          console.log('Selected Level ID:', selectedHierarchyLevel);
          const foundLevel = hierarchyStack.find(l => l.id === selectedHierarchyLevel);
          console.log('Found Level Object in Stack:', foundLevel);
          if (foundLevel) {
            console.log('Type of Found Level:', `'${foundLevel.type}'`);
            console.log('Is Type === "append"?', foundLevel.type === 'append');
          } else {
            console.log('Level not found in hierarchyStack.');
          }
          console.log('--- END DEBUG ---');
        }
      }, [selectedHierarchyLevel, hierarchyStack, hierarchyMode]);
      // --- END TEMPORARY DEBUG CODE ---
      const docRef = useRef(null);
      
      // Memoized filtered lines for virtualization
      const filteredLines = useMemo(() => {
        if (!debouncedFileContent) return [];
        return debouncedFileContent.split('\n');
      }, [debouncedFileContent]);
      
      // Memoized line positions cache for efficient position lookups
      const linePositions = useMemo(() => {
        if (!filteredLines.length) return [];
        const positions = [0];
        let currentPos = 0;
        for (let i = 0; i < filteredLines.length - 1; i++) {
          currentPos += filteredLines[i].length + 1; // +1 for newline
          positions.push(currentPos);
        }
        return positions;
      }, [filteredLines]);

      // Memoized list of rules for display in the sidebar
      const displayableRules = useMemo(() => {
        if (hierarchyMode) {
          // If in hierarchy mode, get all rules from all levels with levelId
          return hierarchyStack.flatMap(level => 
            (level.rules || []).map(rule => ({ ...rule, levelId: level.id }))
          );
        }
        // Otherwise, just use the simple rules list
        return rules;
      }, [hierarchyMode, rules, hierarchyStack]);

      const appendFieldNames = useMemo(() => {
        if (!hierarchyMode || hierarchyStack.length === 0) return [];
        const names = new Set();
        hierarchyStack.forEach(level => {
          (level.rules || []).forEach(rule => {
            if (rule.level === 'append' || level.type === 'append' || rule.type === 'append') {
              if (rule.fieldName) names.add(rule.fieldName);
            }
          });
        });
        return Array.from(names);
      }, [hierarchyMode, hierarchyStack]);
      
      // Helper function to get highlighted HTML for a specific line
      const getLineHighlight = useCallback((lineIndex) => {
        const line = filteredLines[lineIndex];
        if (!line) return escapeHtml('');
        
        if (!highlightsEnabled) return escapeHtml(line);
        
        // Calculate line start position in the full document
        const lineStart = linePositions[lineIndex] || 0;
        const lineEnd = lineStart + line.length;
        
        let events = [];
        
        // Add extraction rule highlights for this line
        displayableRules.forEach(rule => {
          if (rule.testResults) {
            rule.testResults.forEach(result => {
              if (result.isEmpty) return;
              
              if (result.startIndex !== undefined && result.length !== undefined) {
                // Check if this highlight intersects with the current line
                const highlightStart = result.startIndex;
                const highlightEnd = result.startIndex + result.length;
                
                if (highlightStart < lineEnd && highlightEnd > lineStart) {
                  // Calculate relative positions within the line
                  const relativeStart = Math.max(0, highlightStart - lineStart);
                  const relativeEnd = Math.min(line.length, highlightEnd - lineStart);
                  
                  if (relativeStart < relativeEnd) {
                    // Check for append level first, then fall back to ruleType
                    let className = `match-${rule.ruleType.toLowerCase()}`; // Default
                    if (rule.level === 'append') {
                      className = 'match-append'; // Override for append rules
                    }

                    const tooltip = `title="${escapeHtml(`${rule.fieldName}: ${result.value}`)}"`;
                    events.push({
                      pos: relativeStart,
                      type: 'open',
                      tag: `<span class="${className}" data-rule-id="${rule.id}" ${tooltip}>`
                    });
                    events.push({ 
                      pos: relativeEnd, 
                      type: 'close', 
                      tag: '</span>' 
                    });
                  }
                }
              }
            });
          }
        });
        
        // Check if line is excluded
        const isExcluded = isLineExcluded(line);
        if (isExcluded) {
          const trimmed = line.trim();
          if (trimmed) {
            const firstNonSpace = line.search(/\S/);
            const lastNonSpace = line.search(/\S\s*$/);
            const startIndex = firstNonSpace >= 0 ? firstNonSpace : 0;
            const endIndex = lastNonSpace >= 0 ? lastNonSpace + 1 : line.length;
            
            events.push({
              pos: startIndex,
              type: 'open',
              tag: `<span class="match-excluded" title="Excluded header: ${escapeHtml(trimmed)}">`
            });
            events.push({
              pos: endIndex,
              type: 'close', 
              tag: '</span>'
            });
          }
        }
        
        // Apply highlights to the line
        if (events.length === 0) {
          return escapeHtml(line);
        }
        
        // Sort events: by position, closes before opens at same pos
        events.sort((a, b) => a.pos - b.pos || (a.type === 'close' ? -1 : 1));
        
        let highlighted = '';
        let prevPos = 0;
        
        events.forEach(event => {
          if (prevPos < event.pos) {
            highlighted += escapeHtml(line.slice(prevPos, event.pos));
          }
          highlighted += event.tag;
          prevPos = event.pos;
        });
        
        if (prevPos < line.length) {
          highlighted += escapeHtml(line.slice(prevPos));
        }
        
        return highlighted;
      }, [filteredLines, linePositions, highlightsEnabled, displayableRules, excludePatterns, isLineExcluded]);
      
      // Virtualized row component for react-window (with fallback)
      const VirtualizedRow = React.memo(({ index, style, data }) => {
        // Destructure the new props from data
        const { lines, rules, settings, showPrimaryHighlights, hierarchyMode } = data;
        const line = lines[index];

        // Memoize the regex for performance
        const primaryLineRegex = React.useMemo(() => {
          try {
            return new RegExp(settings.primaryLineIdentifier);
          } catch (e) {
            // Return a regex that will never match if the user input is invalid
            return new RegExp('(?!)');
          }
        }, [settings.primaryLineIdentifier]);

        // Determine if the current line is a primary record anchor
        const isPrimary = hierarchyMode && showPrimaryHighlights && settings.primaryLineIdentifier && primaryLineRegex.test(line);

        // Define the conditional class string
        const rowClasses = `py-0.5 leading-relaxed ${isPrimary ? 'bg-blue-100 border-l-4 border-blue-500' : ''}`;

        const highlightedLine = getLineHighlight(index);
        return (
          <div
            style={style}
            className={rowClasses}
            dangerouslySetInnerHTML={{ __html: highlightedLine }}
          />
        );
      }, (prevProps, nextProps) => {
        // Custom comparison: re-render if rules or lines change
        // This ensures highlights update when testResults are added
        if (prevProps.data.rules !== nextProps.data.rules) return false;
        if (prevProps.data.lines !== nextProps.data.lines) return false;
        if (prevProps.index !== nextProps.index) return false;
        return true; // Skip re-render if nothing relevant changed
      });
      
      // Memoized line highlights for performance
      const lineHighlights = useMemo(() => {
        if (!highlightsEnabled || !debouncedFileContent || !debouncedRules.length) {
          return new Map();
        }
        
        const highlights = new Map();
        const lines = filteredLines;
        
        // Process highlights by line for efficient lookup
        debouncedRules.forEach(rule => {
          if (rule.testResults) {
            rule.testResults.forEach(result => {
              if (!result.error && !result.isEmpty && result.lineNumber !== undefined) {
                const lineNum = result.lineNumber - 1; // Convert to 0-based
                if (!highlights.has(lineNum)) {
                  highlights.set(lineNum, []);
                }
                highlights.get(lineNum).push({
                  ruleId: rule.id,
                  fieldName: rule.fieldName,
                  value: result.value,
                  startIndex: result.startIndex,
                  length: result.length,
                  ruleType: rule.ruleType,
                  className: `match-${rule.ruleType.toLowerCase()}`
                });
              }
            });
          }
        });
        
        return highlights;
      }, [highlightsEnabled, debouncedFileContent, debouncedRules, filteredLines]);
      const templateImportRef = useRef(null);

      // Smart pattern generation for exclusions
      const generateExclusionPatterns = (text) => {
        const patterns = [];
        
        // Exact match (now strict)
        patterns.push({
          type: 'exact',
          name: 'Exact Match',
          description: `Only lines exactly matching "${text}" (case-insensitive, trimmed)`,
          pattern: text,
          isRegex: false
        });
        
        // NEW: Fuzzy match (old behavior as an option)
        patterns.push({
          type: 'fuzzy',
          name: 'Fuzzy Match',
          description: `Lines containing parts of "${text}" or similar words (broad match)`,
          pattern: text,  // Same pattern, but we'll handle fuzzy in wouldLineBeExcluded
          isRegex: false,
          isFuzzy: true   // NEW flag to trigger fuzzy logic
        });
        
        // Number-flexible (unchanged, but add if \d+ present)
        if (/\d/.test(text)) {
          const numberPattern = text.replace(/\d+/g, '\\d+');
          patterns.push({
            type: 'numbers',
            name: 'Flexible Numbers',
            description: `"${text}" but with any numbers (e.g., different pages or IDs)`,
            pattern: numberPattern,
            isRegex: true
          });
        }
        
        // Date-flexible (enhanced for MM-DD-YY)
        if (/\d{1,2}-\d{1,2}-\d{2,4}/.test(text)) {  // UPDATED regex to match - separated
          const datePattern = text.replace(/\d{1,2}-\d{1,2}-\d{2,4}/g, '\\d{1,2}-\\d{1,2}-\\d{2,4}');
          patterns.push({
            type: 'dates',
            name: 'Flexible Dates',
            description: `"${text}" but with any dates (e.g., different periods)`,
            pattern: datePattern,
            isRegex: true
          });
        }
        
        // NEW: Page-flexible (specific for "PAGE \d+")
        if (/PAGE \d+/i.test(text)) {
          const pagePattern = text.replace(/PAGE \d+/i, 'PAGE \\d+');
          patterns.push({
            type: 'pages',
            name: 'Flexible Pages',
            description: `"${text}" but with any page number`,
            pattern: pagePattern,
            isRegex: true
          });
        }
        
        // Word-boundary flexible (unchanged)
        const words = text.split(/\s+/);
        if (words.length > 1) {
          const wordPattern = words.map(word => {
            if (/^\d+$/.test(word)) return '\\d+';
            if (word.length <= 2) return word.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
            return word.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
          }).join('\\s+');
          
          if (wordPattern !== text.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')) {
            patterns.push({
              type: 'words',
              name: 'Flexible Words',
              description: `Similar structure to "${text}" with word matching`,
              pattern: wordPattern,
              isRegex: true
            });
          }
        }
        
        return patterns;
      };

      // Preview what lines would be excluded by a pattern
      const previewExclusion = (pattern) => {
        if (!fileContent) return [];
        
        const lines = fileContent.split('\n');
        const matchedLines = [];
        
        lines.forEach((line, idx) => {
          if (wouldLineBeExcluded(line, pattern)) {
            matchedLines.push({ lineNumber: idx + 1, content: line.trim() });
          }
        });
        
        return matchedLines;
      };

      // Test if a line would be excluded by a specific pattern
      const wouldLineBeExcluded = (line, pattern) => {
        const lineClean = line.trim().toLowerCase();
        const patternText = pattern.pattern.toLowerCase();
        
        if (lineClean === '') return false;  // NEW: Explicitly skip empty lines unless pattern is empty (which it won't be for headers)
        
        if (!pattern.isRegex) {
          if (pattern.isFuzzy) {
            // IMPROVED fuzzy logic with better precision to prevent over-matching
            if (lineClean === patternText) return true;
            
            // Only check substring inclusion for longer patterns to avoid false positives
            if (patternText.length > 4) {
            if (lineClean.includes(patternText)) return true;
              if (patternText.includes(lineClean) && lineClean.length > 3) return true;
            }
            
            const patternWords = patternText.split(/\s+/).filter(w => w.length > 3);
            const lineWords = lineClean.split(/\s+/).filter(w => w.length > 3);
            
            if (patternWords.length > 0 && lineWords.length > 0) {
              const matchingWords = patternWords.filter(pw => 
                lineWords.some(lw => {
                  // More conservative matching - require substantial overlap
                  if (lw === pw) return true; // Exact word match
                  if (lw.length >= 4 && pw.length >= 4) {
                    // Only allow partial matches for longer words
                    return lw.includes(pw) || pw.includes(lw);
                  }
                  return false;
                })
              );
              // Require at least 50% of pattern words to match, minimum 1, maximum prevents over-matching
              const requiredMatches = Math.max(1, Math.min(Math.ceil(patternWords.length * 0.5), 3));
              if (matchingWords.length >= requiredMatches) return true;
            }
            return false;
          } else {
            // CHANGED: Strict exact match only (trimmed, case-insensitive)
            return lineClean === patternText;
          }
        } else {
          // Regex pattern matching (unchanged)
          try {
            const regex = new RegExp(patternText, 'i');
            return regex.test(lineClean);
          } catch (e) {
            return false;
          }
        }
      };

      // Initialize Web Worker with error handling
      useEffect(() => {
        try {
          const newWorker = createWorker();
          setWorker(newWorker);
          
                  newWorker.onmessage = (e) => {
          const { type, data, progress, totalItems } = e.data;
          
          if (type === 'EXTRACTION_CHUNK') {
            console.log(`üì¶ Received extraction chunk: ${data.length} items (${progress}% complete)`);
            tempExtractionDataRef.current = [...tempExtractionDataRef.current, ...data];
            setProcessingProgress(progress);
          } else if (type === 'EXTRACTION_COMPLETE') {
            if (data) {
              // Small dataset sent directly
              console.log('‚úÖ Extraction complete - small dataset:', data.length, 'items');
              setExtractedData(data);

            } else {
              // Large dataset sent in chunks
              console.log('‚úÖ Extraction complete - chunked dataset:', totalItems, 'total items');
              setExtractedData([...tempExtractionDataRef.current]);
              tempExtractionDataRef.current = []; // Clear temp data
            }

            setIsProcessing(false);
            setProcessingProgress(0);
            setIsUpdatingData(false);
          } else if (type === 'TEST_RESULTS_COMPLETE') {
            const resultsByRuleId = e.data.results;
            const hierarchySettings = e.data.hierarchySettings || {};
            const excludePatterns = e.data.excludePatterns; // Get passed-through patterns
            
            // 1. Compute the new hierarchy stack (pure computation, no side effects)
            let rulesForWorker = [];
            setHierarchyStack(prevStack => {
              const newStack = prevStack.map(level => ({
                ...level,
                rules: level.rules.map(rule => {
                  if (resultsByRuleId[rule.id]) {
                    const updated = { ...rule, testResults: resultsByRuleId[rule.id], data: resultsByRuleId[rule.id].map(r => r.value) };
                    return updated;
                  }
                  return rule;
                })
              }));
              rulesForWorker = newStack.flatMap(level => level.rules);
              return newStack;
            });
            
            // 2. Update simple rules list (pure computation, no side effects)
            let updatedSimpleRules = [];
            setRules(prevRules => {
              updatedSimpleRules = prevRules.map(rule => 
                resultsByRuleId[rule.id] ? 
                { ...rule, testResults: resultsByRuleId[rule.id], data: resultsByRuleId[rule.id].map(r => r.value) } : 
                rule
              );
              return updatedSimpleRules;
            });
            
            // 3. Now trigger side effects AFTER state updates, using setTimeout to ensure state is committed
            setTimeout(() => {
              if (hierarchySettings.mode) {
                // Hierarchy template - trigger PROCESS_HIERARCHY
                if (worker && rulesForWorker.length > 0) {
                  console.log('MAIN: üîÑ Triggering PROCESS_HIERARCHY after populating highlights...');
                  setIsProcessing(true);
                  const templateColumnMapping = hierarchySettings.columnMapping || null;
                  
                  worker.postMessage({ 
                    type: 'PROCESS_HIERARCHY', 
                    data: { 
                      fileContent: debouncedFileContent, 
                      rules: rulesForWorker, 
                      settings: { 
                        primaryLineIdentifier: hierarchySettings.identifier, 
                        columnPositions: columnPositions,
                        columnMapping: templateColumnMapping
                      }, 
                      excludePatterns: excludePatterns
                    } 
                  });
                } else {
                  console.warn('‚ö†Ô∏è Cannot process hierarchy - worker not found or no rules');
                  setIsApplyingTemplate(false);
                }
              } else {
                // Simple template - trigger extraction
                setIsApplyingTemplate(false);
                console.log('MAIN: üèÅ Simple template application complete.');
                if (updatedSimpleRules.length > 0 && updatedSimpleRules.some(r => r.testResults)) {
                  console.log('MAIN: üîÑ Triggering extraction for simple template rules...');
                  updateExtractedData(updatedSimpleRules, hierarchySettings.columnMapping || null);
                }
              }
            }, 0);
          } else if (type === 'HIERARCHY_CHUNK') {
            console.log(`üì¶ Received hierarchy chunk: ${data.length} items (${progress}% complete)`);
            tempExtractionDataRef.current = [...tempExtractionDataRef.current, ...data];
            setProcessingProgress(progress);
          } else if (type === 'HIERARCHY_COMPLETE') {
            if (data) {
              // Small dataset sent directly
              console.log('‚úÖ Hierarchy complete - small dataset:', data.length, 'items');
              setHierarchyData(data);
              setExtractedData(data); // Also update the main extracted data for compatibility
            } else {
              // Large dataset sent in chunks
              console.log('‚úÖ Hierarchy complete - chunked dataset:', totalItems, 'total items');
              const finalData = [...tempExtractionDataRef.current];
              setHierarchyData(finalData);
              setExtractedData(finalData);
              tempExtractionDataRef.current = []; // Clear temp data
            }

            setIsProcessing(false);
            setProcessingProgress(0);
            setIsUpdatingData(false);
            setIsApplyingTemplate(false); // Add this line
            console.log('MAIN: üèÅ Hierarchy template application complete.');
          }
        };
          
          newWorker.onerror = (error) => {
            console.warn('Web Worker error:', error);
            setIsProcessing(false);
            setProcessingProgress(0);
            setIsUpdatingData(false);
            setIsApplyingTemplate(false);
          };
          
          return () => {
            newWorker.terminate();
          };
        } catch (error) {
          console.warn('Web Worker not supported:', error);
          // App will work without Web Worker, just slower for large files
        }
      }, []);
      
      // Load templates from localStorage on mount
      useEffect(() => {
        const savedTemplates = JSON.parse(localStorage.getItem('extractionTemplates') || '[]');
        setTemplates(savedTemplates);
      }, []);

      // Save templates to localStorage whenever they change
      useEffect(() => {
        localStorage.setItem('extractionTemplates', JSON.stringify(templates));
      }, [templates]);

      // File upload handler
      const handleFileUpload = (e) => {
        const file = e.target.files[0];
        if (!file) return;
        if (file.type !== 'text/plain' && !file.name.endsWith('.txt')) {
          alert('Please upload a plain text (.txt) file');
          return;
        }
        setFileName(file.name);
        const reader = new FileReader();
        reader.onload = (ev) => {
          const normalized = ev.target.result.replace(/\f/g, '\n').replace(/\r/g, '');
          setFileContent(normalized);
          setRules([]);
          setExtractedData([]);
        };
        reader.readAsText(file);
      };

      // Load sample data
      const loadSample = () => {
        const sample = `PARTS INVENTORY REPORT

PART: 000-A Widget Assembly Set
   VENDOR: ACME-CORP
   PRICE: 45.50
   STOCK: 120

PART: 001-B Valve Component Kit
   VENDOR: DELTA-SUPPLY
   PRICE: 28.75
   STOCK: 85

PART: 002-C Gasket Universal Pack
   VENDOR: ACME-CORP
   PRICE: 12.00
   STOCK: 200

PART: 003-D Pipe Joint Assembly
   VENDOR: STEEL-WORKS
   PRICE: 67.25
   STOCK: 45

PART: 004-E Bolt Hardware Set
   VENDOR: BOLT-KING
   PRICE: 15.80
   STOCK: 300`;
        setFileName('sample_parts_report.txt');
        setFileContent(sample);
        setRules([]);
        setExtractedData([]);
        setHierarchyStack([]);
        setHierarchyMode(false);
        setBreakoutEnabled(false);
      };

      // Hierarchy management functions
      const migrateToHierarchy = useCallback(() => {
        if (rules.length === 0) return;

        // We only care about primary rules from the simple list.
        const primaryRules = rules.filter(r => r.ruleType !== 'APPEND');

        const newStack = [];

        // Create detail level with primary rules
        if (primaryRules.length > 0) {
          newStack.push({
            id: 'detail-' + Date.now(),
            type: 'detail',
            name: 'Detail Level',
            rules: primaryRules.map(r => ({ ...r, type: r.ruleType })),
            scope: { terminator: 'nextLevel', indentBreak: false, blankLines: 1 }
          });
        }

        setHierarchyStack(newStack);
        setHierarchyMode(true);
        setShowHierarchyView(true);
      }, [rules]);

      const migrateFromHierarchy = useCallback(() => {
        const flatRules = [];
        hierarchyStack.forEach(level => {
          level.rules.forEach(rule => {
            flatRules.push({ ...rule });
          });
        });
        setRules(flatRules);
        setHierarchyStack([]);
        setHierarchyMode(false);
        setShowHierarchyView(false);
        setBreakoutEnabled(false);
      }, [hierarchyStack]);

      const addHierarchyLevel = useCallback((type, name = '') => {
        const newLevel = {
          id: `${type}-${Date.now()}`,
          type,
          name: name || `${type.charAt(0).toUpperCase() + type.slice(1)} Level`,
          rules: [],
          scope: {
            terminator: type === 'detail' ? 'nextLevel' : 'indentBreak',
            indentBreak: type === 'append',
            blankLines: type === 'detail' ? 1 : 2
          }
        };
        setHierarchyStack(prev => [...prev, newLevel]);
      }, []);

      const updateHierarchyLevel = useCallback((levelId, updates) => {
        setHierarchyStack(prev => prev.map(level =>
          level.id === levelId ? { ...level, ...updates } : level
        ));
      }, []);

      const removeHierarchyLevel = useCallback((levelId) => {
        setHierarchyStack(prev => prev.filter(level => level.id !== levelId));
      }, []);

      const moveHierarchyLevel = useCallback((fromIndex, toIndex) => {
        setHierarchyStack(prev => {
          const newStack = [...prev];
          const [moved] = newStack.splice(fromIndex, 1);
          newStack.splice(toIndex, 0, moved);
          return newStack;
        });
      }, []);

      // Text selection handler (with crash protection)
      const handleTextSelection = () => {
        try {
          const selection = window.getSelection();
          const text = selection.toString().trim();
          if (!text) return;

        if (excludeMode) {
          // Show exclusion options instead of immediately adding
          const patterns = generateExclusionPatterns(text);
          setPendingExclusion({ text, patterns });
          setShowExcludeOptions(true);
          selection.removeAllRanges();
          return;
        }


        if (!selectionMode) return;

        console.log('üéØ Starting rule creation for text:', text.substring(0, 50) + '...');
        setCurrentSelection({ text });
        setShowRuleBuilder(true);
        setFieldName('');
        setRuleDescription('');
        
        // Smart pattern suggestions
        if (text.match(/\d{1,2}\/\d{1,2}\/\d{4}/)) {
          setDataType('DATE');
          setRuleType('PATTERN');
          setPattern('(\\d{1,2}/\\d{1,2}/\\d{4})');
        } else if (text.match(/\$[\d,]+\.?\d*/)) {
          setDataType('CURRENCY');
          setRuleType('PATTERN');
          setPattern('\\$([\\d,]+\\.?\\d*)');
        } else if (text.match(/^\d+\.?\d*$/)) {
          setDataType('NUMBER');
          setRuleType('PATTERN');
          setPattern('(\\d+\\.?\\d*)');
        } else if (text.includes(':')) {
          // Labeled data - suggest the universal pattern
          const parts = text.split(':');
          const label = parts[0].trim();
          setDataType('TEXT');
          setRuleType('PATTERN');
          setPattern(`${label}:\\s+(.+?)(?:\\s|$)`);
        } else {
          setDataType('TEXT');
          setRuleType('SINGLE');
          setPattern(text.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'));
        }
        
        selection.removeAllRanges();
        } catch (error) {
          console.error('‚ùå Error in text selection handler:', error);
          // Clear selection state on error
          setCurrentSelection(null);
          setShowRuleBuilder(false);
          setIsTestingPattern(false);
        }
      };

      // Check if line should be excluded
      const isLineExcluded = (line) => {
        return excludePatterns.some(pattern => wouldLineBeExcluded(line, pattern));
      };

      // Test if a line matches a rule pattern
      const testPatternForLine = (line, rule) => {
        try {
          if (rule.ruleType === 'PATTERN' || rule.ruleType === 'APPEND') {
            const regex = new RegExp(rule.pattern, 'i');
            return regex.test(line);
          } else if (rule.ruleType === 'SINGLE') {
            const escapedPattern = rule.pattern.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
            const regex = new RegExp(escapedPattern, 'i');
            return regex.test(line);
          } else if (rule.ruleType === 'POSITION') {
            // For position rules, we need more context, but for grouping just return basic match
            return line.trim().length > 0 && !isLineExcluded(line);
          }
          return false;
        } catch (error) {
          return false;
        }
      };



      // (escapeHtml function is already defined above)

      // Helper for trailing negatives (unicode escapes to avoid paste issues)
      const handleTrailingNegative = (val) => {
        val = val.trim();
        const trailingMinusRegex = /[\u002D\u2212\u2013\u2014]$/; // ASCII -, math minus, en-dash, em-dash at end
        if (trailingMinusRegex.test(val)) {
          const cleanVal = val.replace(trailingMinusRegex, '').trim();
          return '-' + cleanVal;
        }
        return val;
      };

      // Helper to create clean rule config for templates with rich metadata
      const sanitizeRuleForTemplate = (rule, levelType) => {
        const sampleMatches = rule.testResults ? rule.testResults.slice(0, 3).map(r => r.value).filter(v => v) : [];
        
        // Determine expectation based on rule type and results
        let expectation = 'multiple';
        if (rule.ruleType === 'SINGLE' || rule.pattern?.includes('PO Number') || rule.pattern?.includes('Total') || rule.pattern?.includes('Date')) {
          expectation = 'exactly_one';
        } else if (sampleMatches.length === 0) {
          expectation = 'optional';
        }

        // Use user description if available, otherwise generate smart description
        let description = rule.description || '';
        if (!description) {
          if (rule.ruleType === 'PATTERN') {
            if (rule.dataType === 'CURRENCY') {
              description = `Currency amounts matching pattern`;
            } else if (rule.dataType === 'DATE') {
              description = `Date values matching pattern`;
            } else {
              description = `Text matching: ${rule.pattern}`;
            }
          } else if (rule.ruleType === 'POSITION') {
            if (rule.pattern.startsWith('column:')) {
              const col = rule.pattern.split(':')[1];
              description = `Values from column ${col}`;
            } else if (rule.pattern.startsWith('line:')) {
              const line = rule.pattern.split(':')[1];
              description = `Content from line ${line}`;
            }
          } else if (rule.ruleType === 'SINGLE') {
            description = `Exact text: "${rule.text}"`;
          }
        }
        const result = {
          fieldName: rule.fieldName,
          ruleType: rule.ruleType,
          dataType: rule.dataType,
          pattern: rule.pattern,
          level: levelType, // Save levelType directly (can be 'append', 'detail', or 'primary')
          description,
          sampleMatches,
          expectation,
          foundMatches: sampleMatches.length > 0
        };

        // Save append-specific properties if this rule is in an 'append' level
        if (levelType === 'append') {
          result.primaryRuleId = rule.primaryRuleId;
          result.scope = rule.scope || 'proximity';
          result.onEmpty = rule.onEmpty || 'null'; // Correctly save 'null' if it's set
        }
        return result;
      };

      // Helper to compute test results for a specific rule config (optimized for large files)
      const computeTestResultsForConfig = (config, isLineExcludedFn = isLineExcluded, hierarchySettings = null) => {
        // Timeout wrapper to prevent crashes
        const timeoutPromise = new Promise((resolve) => {
          setTimeout(() => {
            console.warn('‚è∞ Processing timeout for:', config.fieldName);
            resolve([]);
          }, 3000); // 3 second timeout
        });
        
        const computePromise = new Promise((resolve) => {
          // Actual computation (wrapped to make it async)
          setTimeout(() => {
            resolve(computeTestResultsSync(config, isLineExcludedFn, hierarchySettings));
          }, 0);
        });
        
        // For now, just run synchronously but with limits
        return computeTestResultsSync(config, isLineExcludedFn, hierarchySettings);
      };
      
      // Full content extraction for final data (no limits) - WITH EXCLUSIONS APPLIED
      const computeTestResultsForConfigFullContent = (rule) => {
        console.log('üîÑ Computing full results for:', rule.fieldName, '- Applying', excludePatterns.length, 'exclusion patterns');
        
        if (!rule.pattern || !debouncedFileContent) {
          return [];
        }
        
        // Create exclusion checker for this extraction
        const isLineExcluded = (line) => {
          return excludePatterns.some(pattern => wouldLineBeExcluded(line, pattern));
        };
        
        try {
          let matches = [];
          
          if (rule.ruleType === 'PATTERN') {
            const regex = new RegExp(rule.pattern, 'gim');
            let match;
            while ((match = regex.exec(debouncedFileContent)) !== null) {
              const fullMatch = match[0];
              const value = match[1] !== undefined ? match[1] : fullMatch;
              const fullIndex = match.index;
              const valueOffset = fullMatch.indexOf(value);
              const startIndex = fullIndex + valueOffset;
              const length = value.length;
              
              // Check if this match is on an excluded line
              const lines = filteredLines;
              // Use cached line positions for efficient line index calculation  
              const lineIndex = linePositions.findIndex((pos, idx) => 
                idx === linePositions.length - 1 || 
                (startIndex >= pos && startIndex < linePositions[idx + 1])
              );
              const currentLine = lines[lineIndex] || '';
              
              if (!isLineExcluded(currentLine)) {
                matches.push({
                  value,
                  fullMatch,
                  startIndex,
                  length
                });
              } else {
                console.log('üö´ Excluded match on line', lineIndex + 1, ':', value);
              }
            }
          } else if (rule.ruleType === 'SINGLE') {
            const regex = new RegExp(rule.pattern.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gi');
            let match;
            while ((match = regex.exec(debouncedFileContent)) !== null) {
              const fullMatch = match[0];
              const value = fullMatch;
              const startIndex = match.index;
              const length = value.length;
              
              // Check if this match is on an excluded line
              const lines = filteredLines;
              // Use cached line positions for efficient line index calculation  
              const lineIndex = linePositions.findIndex((pos, idx) => 
                idx === linePositions.length - 1 || 
                (startIndex >= pos && startIndex < linePositions[idx + 1])
              );
              const currentLine = lines[lineIndex] || '';
              
              if (!isLineExcluded(currentLine)) {
                matches.push({
                  value,
                  fullMatch,
                  startIndex,
                  length
                });
              } else {
                console.log('üö´ Excluded match on line', lineIndex + 1, ':', value);
              }
            }
          } else if (rule.ruleType === 'POSITION') {
            // For position rules, we need to process the full content properly WITH exclusions

            matches = computeTestResultsSync({
              pattern: rule.pattern,
              ruleType: rule.ruleType,
              dataType: rule.dataType,
              fieldName: rule.fieldName
            }, isLineExcluded); // Pass the exclusion function!
          }
          

          return matches;
        } catch (error) {
          console.error('‚ùå Error in full extraction for:', rule.fieldName, error);
          return [{ error: 'Extraction error: ' + error.message }];
        }
      };
      
      // Synchronous computation with safety limits - PERFORMANCE OPTIMIZED
      const computeTestResultsSync = (config, isLineExcludedFn = isLineExcluded, hierarchySettings = null) => {
        const fieldName = config.fieldName || 'Unnamed Rule';
        console.log('üßÆ Computing test results for:', fieldName, 'Type:', config.ruleType);
        
        // Use debounced content for better performance
        const contentToUse = debouncedFileContent || fileContent;
        // Use cached lines for efficiency
        const linesToUse = filteredLines;
        
        if (!config.pattern || !contentToUse) {
          console.log('‚ö†Ô∏è Missing pattern or file content for:', fieldName);
          return [];
        }
        
        const isLargeFile = linesToUse.length > 10000;
        const processingContent = contentToUse;

        // Determine hierarchy context for filtering lines
        const ruleLevel = config.level === 'append' ? 'append' : 'primary';
        let primaryLineRegex = null;

        if (hierarchySettings?.mode && hierarchySettings?.identifier) {
          try {
            primaryLineRegex = new RegExp(hierarchySettings.identifier);
          } catch (error) {
            console.warn('Invalid primaryLineIdentifier regex:', hierarchySettings.identifier, error);
            primaryLineRegex = /(?!)/; // Non-matching regex as fallback
          }
        }

        // Get columnMapping from hierarchySettings, or build from outer scope
        let effectiveColumnMapping = hierarchySettings?.columnMapping;
        if (effectiveColumnMapping === undefined) {
          // Build from outer scope if available
          effectiveColumnMapping = (columnMappingEnabled && columnMappingSpec) ? {
            spec: columnMappingSpec,
            mappings: columnMappings
          } : null;
        }
        
        // Get columnPositions from hierarchySettings, or use outer scope, or compute from columnMapping
        let effectiveColumnPositions = hierarchySettings?.columnPositions;
        if (effectiveColumnPositions === undefined) {
          // Use outer scope columnPositions (React state from useMemo)
          effectiveColumnPositions = columnPositions;
        }
        
        // Compute columnPositions from columnMapping if available (prioritize columnMapping)
        if (effectiveColumnMapping && effectiveColumnMapping.spec && effectiveColumnMapping.spec.boundaries && effectiveColumnMapping.spec.boundaries.length > 0) {
          effectiveColumnPositions = effectiveColumnMapping.spec.boundaries
            .slice()
            .sort((a, b) => a.start - b.start)
            .map(b => ({
              start: Math.max(0, (b.start ?? 1) - 1),
              end: Math.max(0, (b.end ?? b.start) - 1),
              isMerged: false
            }));
        }
        
        // Use effective values for the rest of the function
        const columnPositions = effectiveColumnPositions;
        const columnMapping = effectiveColumnMapping;
        
        // Local resolver function that uses the columnMapping parameter
        const resolveColumnIndexLocal = (columnIdentifier) => {
          // Remove quotes if present (e.g., "Inv Date" -> Inv Date)
          let identifier = columnIdentifier.trim();
          if ((identifier.startsWith('"') && identifier.endsWith('"')) || 
              (identifier.startsWith("'") && identifier.endsWith("'"))) {
            identifier = identifier.slice(1, -1).trim();
          }
          
          // If it's already a number, return it
          const num = parseInt(identifier);
          if (!isNaN(num) && num.toString() === identifier) {
            return num;
          }
          
          // Otherwise, treat it as a field name and look it up using columnMapping
          if (columnMapping && columnMapping.spec && columnMapping.spec.boundaries && columnMapping.mappings) {
            // Find the mapping with this field name (case-insensitive, trimmed)
            const normalizedName = identifier.toLowerCase().trim();
            const mapping = columnMapping.mappings.find(m => 
              m.fieldName && m.fieldName.toLowerCase().trim() === normalizedName
            );
            
            if (mapping) {
              // Find the index of this columnId in the sorted boundaries
              const sortedBoundaries = [...columnMapping.spec.boundaries].sort((a, b) => a.start - b.start);
              const index = sortedBoundaries.findIndex(b => b.id === mapping.columnId);
              if (index >= 0) {
                return index + 1; // Return 1-based index
              }
            }
          }
          
          return null;
        };

        try {
          let matches = [];
          let totalIterations = 0;
          
          if (config.ruleType === 'PATTERN') {
            const regex = new RegExp(config.pattern, 'gim');
            let match;

            if (!hierarchySettings?.mode || !primaryLineRegex) {
              // Original logic for non-hierarchy mode
              let matchCount = 0;
              while ((match = regex.exec(processingContent)) !== null) {
                totalIterations++;
                if (totalIterations > 50000) {
                  console.warn('‚ö†Ô∏è Max iterations reached for:', fieldName);
                  break;
                }

                const fullMatch = match[0];
                const value = match[1] !== undefined ? match[1] : fullMatch;
                const fullIndex = match.index;
                const valueOffset = fullMatch.indexOf(value);
                const startIndex = fullIndex + valueOffset;
                const length = value.length;
                const trimmedValue = value.trim();
                matches.push({
                  value: trimmedValue,
                  fullMatch,
                  startIndex,
                  length,
                  isEmpty: trimmedValue === ''
                });
                matchCount++;
              }
            } else {
              // Hierarchy-aware logic: filter lines before testing
              const lines = linesToUse;
              let currentPos = 0;

              lines.forEach((line, idx) => {
                if (isLineExcludedFn(line)) {
                  currentPos += line.length + 1;
                  return;
                }

                // Apply hierarchy filter
                const isPrimaryLine = primaryLineRegex.test(line);
                if (ruleLevel === 'primary' && !isPrimaryLine) {
                  currentPos += line.length + 1;
                  return;
                }
                if (ruleLevel === 'append' && isPrimaryLine) {
                  currentPos += line.length + 1;
                  return;
                }

                // Test regex on this single line
                let lineMatch;
                const lineRegex = new RegExp(config.pattern, 'gim');
                while ((lineMatch = lineRegex.exec(line)) !== null) {
                  totalIterations++;
                  if (totalIterations > 50000) {
                    console.warn('‚ö†Ô∏è Max iterations reached for:', fieldName);
                    return;
                  }

                  const fullMatch = lineMatch[0];
                  const value = lineMatch[1] !== undefined ? lineMatch[1] : fullMatch;
                  const lineStartIndex = lineMatch.index;
                  const valueOffset = fullMatch.indexOf(value);
                  const startIndexInLine = lineStartIndex + valueOffset;
                  const documentStartIndex = currentPos + startIndexInLine;
                  const length = value.length;
                  const trimmedValue = value.trim();

                  matches.push({
                    value: trimmedValue,
                    fullMatch,
                    startIndex: documentStartIndex,
                    length,
                    isEmpty: trimmedValue === ''
                  });
                }

                currentPos += line.length + 1;
              });
            }
          } else if (config.ruleType === 'SINGLE') {
            console.log('üìù Processing SINGLE rule for:', fieldName);
            const escapedPattern = config.pattern.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
            console.log('üîí Escaped pattern for', fieldName, ':', escapedPattern);

            if (!hierarchySettings?.mode || !primaryLineRegex) {
              // Original logic for non-hierarchy mode
              const regex = new RegExp(escapedPattern, 'gi');
              let match;
              let matchCount = 0;
              while ((match = regex.exec(processingContent)) !== null && matchCount < maxMatches) {
                totalIterations++;
                if (totalIterations > 50000) {
                  console.warn('‚ö†Ô∏è Max iterations reached for:', fieldName);
                  break;
                }

                const fullMatch = match[0];
                const value = fullMatch;
                const startIndex = match.index;
                const length = value.length;
                matches.push({
                  value,
                  fullMatch,
                  startIndex,
                  length
                });
                matchCount++;
              }
            } else {
              // Hierarchy-aware logic: filter lines before testing
              const lines = linesToUse;
              let currentPos = 0;

              lines.forEach((line, idx) => {
                if (isLineExcludedFn(line)) {
                  currentPos += line.length + 1;
                  return;
                }

                // Apply hierarchy filter
                const isPrimaryLine = primaryLineRegex.test(line);
                if (ruleLevel === 'primary' && !isPrimaryLine) {
                  currentPos += line.length + 1;
                  return;
                }
                if (ruleLevel === 'append' && isPrimaryLine) {
                  currentPos += line.length + 1;
                  return;
                }

                // Test regex on this single line
                let lineMatch;
                const lineRegex = new RegExp(escapedPattern, 'gi');
                let matchCount = 0;
                while ((lineMatch = lineRegex.exec(line)) !== null && matchCount < maxMatches) {
                  totalIterations++;
                  if (totalIterations > 50000) {
                    console.warn('‚ö†Ô∏è Max iterations reached for:', fieldName);
                    return;
                  }

                  const fullMatch = lineMatch[0];
                  const value = fullMatch;
                  const lineStartIndex = lineMatch.index;
                  const documentStartIndex = currentPos + lineStartIndex;
                  const length = value.length;

                  matches.push({
                    value,
                    fullMatch,
                    startIndex: documentStartIndex,
                    length
                  });
                  matchCount++;
                }

                currentPos += line.length + 1;
              });
            }
          } else if (config.ruleType === 'POSITION') {


            // Use full lines array with virtualized highlighting
            const lines = linesToUse;
            let currentPos = 0;
            let matchCount = 0;
            lines.forEach((line, idx) => {

              if (isLineExcludedFn(line)) {
                currentPos += line.length + 1;
                return;
              }

              // Apply hierarchy filter if in hierarchy mode
              if (hierarchySettings?.mode && primaryLineRegex) {
                const isPrimaryLine = primaryLineRegex.test(line);
                if (ruleLevel === 'primary' && !isPrimaryLine) {
                  currentPos += line.length + 1;
                  return;
                }
                if (ruleLevel === 'append' && isPrimaryLine) {
                  currentPos += line.length + 1;
                  return;
                }
              }

              if (line.match(/^[-\s]*$/) || line.match(/^-{5,}/)) {
                currentPos += line.length + 1;
                return;
              }

              if (config.pattern.startsWith('line:')) {
                const lineNum = parseInt(config.pattern.split(':')[1]);
                if (idx + 1 === lineNum) {
                  let value = line.trim();
                  const firstNonSpace = line.search(/\S/);
                  const startIndex = currentPos + (firstNonSpace >= 0 ? firstNonSpace : 0);
                  const length = value.length;
                  if (value) {
                    matches.push({ 
                      value, 
                      fullMatch: line, 
                      startIndex, 
                      length,
                      lineNumber: idx + 1 
                    });
                  }
                }
              } else if (config.pattern.startsWith('column:')) {
                const columnSpec = config.pattern.split(':')[1];

                if (columnSpec.includes('-')) {
                  // Range-based extraction: column:1-20
                  const [start, end] = columnSpec.split('-').map(n => parseInt(n));
                  if (line.length >= start) {
                    const sub = line.substring(start - 1, end);
                    let value = sub.trim();
                    
                    // Always create a match, even if empty, to maintain column alignment
                    let startIndex, displayLength;
                    
                    if (value && !value.match(/^[-\s]*$/)) {
                      // Non-empty value
                      const firstNonSpace = sub.search(/\S/);
                      startIndex = currentPos + (start - 1) + (firstNonSpace >= 0 ? firstNonSpace : 0);
                      displayLength = value.length;
                      
                      // Handle trailing negatives for data extraction
                      if (config.dataType === 'NUMBER' || config.dataType === 'CURRENCY') {
                        if (end < line.length && /[\u002D\u2212\u2013\u2014]/.test(line[end])) {
                          value += line[end]; // Extract the negative
                          // BUT keep displayLength as original for clean highlighting
                        }
                      }

                      value = handleTrailingNegative(value);

                      // Validation after handling - if invalid, treat as empty but still include
                      if ((config.dataType === 'NUMBER' || config.dataType === 'CURRENCY') && !value.replace(/,/g, '').match(/^-?\d+\.?\d*$/)) {
                        value = '';
                        // For invalid values, highlight the first character of the range
                        startIndex = currentPos + (start - 1);
                        displayLength = 1;
                      }
                    } else {
                      // Empty value - highlight minimal position
                      value = '';
                      // Find the first valid character position in the range
                      const rangeStart = Math.max(0, start - 1);
                      const actualStart = Math.min(rangeStart, line.length - 1);
                      startIndex = currentPos + actualStart;
                      displayLength = 1;
                    }

                    matches.push({ 
                      value, 
                      fullMatch: line, 
                      startIndex, 
                      length: displayLength,
                      lineNumber: idx + 1,
                      isEmpty: value === ''
                    });
                  }
                } else {
                  // Smart column: Use fixed-width if detected, else fallback to split
                  // Support both numeric (column:1) and named (column:"Inv Date") references
                  const columnNum = resolveColumnIndexLocal(columnSpec.trim());
                  
                  if (columnNum === null) {
                    // Invalid column name or number, skip this line
                    console.warn('‚ö†Ô∏è Could not resolve column:', columnSpec, 'columnMapping available:', !!columnMapping);
                    currentPos += line.length + 1;
                    return;
                  }
                  
                  let value = '';
                  let startIndex;
                  let length;
                  let isEmpty = false;

                  if (columnPositions && columnPositions.length >= columnNum) {
                    // Fixed-width mode with proper empty column handling
                    const pos = columnPositions[columnNum - 1];
                    const sub = line.substring(pos.start, pos.end + 1);
                    value = sub.trim();
                    
                    if (pos.isMerged && value) {
                      if (config.dataType === 'TEXT' || config.dataType === 'DATE') {
                        value = value.replace(/\s{2,}.*$/, '').trim();
                      } else {
                        value = value.replace(/^.*\s{2,}/, '').trim();
                      }
                    }
                    
                    let displayLength, valuePos;
                    
                    if (value) {
                      // Non-empty value
                      valuePos = sub.indexOf(value);
                      if (valuePos < 0) {
                        valuePos = sub.search(/\S/) >= 0 ? sub.search(/\S/) : 0;
                      }
                      displayLength = value.length;

                      // Handle trailing negatives for data extraction
                      if (config.dataType === 'NUMBER' || config.dataType === 'CURRENCY') {
                        if (pos.end + 1 < line.length && /[\u002D\u2212\u2013\u2014]/.test(line[pos.end + 1])) {
                          value += line[pos.end + 1]; // Extract the negative
                          // BUT keep displayLength as original for clean highlighting
                        }
                      }

                      value = handleTrailingNegative(value);

                      // Validation after handling - if invalid, treat as empty but still include
                      if ((config.dataType === 'NUMBER' || config.dataType === 'CURRENCY') && !value.replace(/,/g, '').match(/^-?\d+\.?\d*$/)) {
                        value = '';
                        isEmpty = true;
                        // For invalid values, highlight first position of column
                        valuePos = 0;
                        displayLength = 1;
                      }
                    } else {
                      // Empty column - highlight minimal position
                      isEmpty = true;
                      valuePos = 0;
                      displayLength = 1;
                    }

                    startIndex = currentPos + pos.start + valuePos;
                    length = displayLength;
                    matches.push({ 
                      value, 
                      fullMatch: line, 
                      startIndex, 
                      length, 
                      lineNumber: idx + 1,
                      isEmpty
                    });
                  } else {
                    // Enhanced fallback split mode with empty column preservation
                    const originalColumns = line.split(/\s{2,}/);
                    const columns = originalColumns.map(col => col.trim());
                    
                    // Ensure we have enough columns (pad with empty if needed)
                    while (columns.length < columnNum) {
                      columns.push('');
                    }
                    
                    if (columns.length >= columnNum) {
                      value = columns[columnNum - 1] || '';
                      isEmpty = value === '';
                      
                      // Find position of this column in original line
                      let pos = 0;
                      let foundStart = -1;
                      
                      for (let c = 0; c < columnNum; c++) {
                        if (c < originalColumns.length && originalColumns[c]) {
                          const originalCol = originalColumns[c];
                          const found = line.indexOf(originalCol, pos);
                          if (found !== -1) {
                            if (c === columnNum - 1) {
                              // Found our target column
                              if (!isEmpty) {
                                foundStart = found + originalCol.indexOf(value);
                                if (foundStart < found) foundStart = found;
                              } else {
                                // Empty column - point to end of previous column or start of line
                                foundStart = found + originalCol.length;
                              }
                              break;
                            }
                            pos = found + originalCol.length;
                            // Skip whitespace
                            while (pos < line.length && /\s/.test(line[pos])) pos++;
                          }
                        } else if (c === columnNum - 1) {
                          // This is our target column but it doesn't exist in original
                          foundStart = Math.min(pos, line.length - 1);
                          isEmpty = true;
                          value = '';
                          break;
                        }
                      }
                      
                      if (!isEmpty) {
                        // Handle trailing negatives for data extraction
                        if (foundStart >= 0) {
                          const end = foundStart + value.length;
                          if (config.dataType === 'NUMBER' || config.dataType === 'CURRENCY') {
                            if (end < line.length && /[\u002D\u2212\u2013\u2014]/.test(line[end])) {
                              value += line[end]; // Extract the negative
                              // Keep original length for highlighting
                            }
                          }
                        }
                        
                        value = handleTrailingNegative(value);
                        
                        // Validation - if invalid, treat as empty but still include
                        if ((config.dataType === 'NUMBER' || config.dataType === 'CURRENCY') && !value.replace(/,/g, '').match(/^-?\d+\.?\d*$/)) {
                          value = '';
                          isEmpty = true;
                        }
                      }
                      
                      // Calculate highlighting parameters
                      let displayLength;
                      if (isEmpty) {
                        displayLength = 1; // Minimal highlight for empty values
                        // Ensure we don't go beyond line length
                        if (foundStart >= line.length) {
                          foundStart = Math.max(0, line.length - 1);
                        }
                      } else {
                        displayLength = columns[columnNum - 1].length; // Use original column length
                      }
                      
                      startIndex = currentPos + Math.max(0, foundStart);
                      length = displayLength;
                      matches.push({ 
                        value, 
                        fullMatch: line, 
                        startIndex, 
                        length, 
                        lineNumber: idx + 1,
                        isEmpty
                      });
                    }
                  }
                }
              } else if (config.pattern.startsWith('chars:')) {
                const [start, end] = config.pattern.split(':')[1].split('-').map(n => parseInt(n));
                if (line.length >= start) {
                  const sub = line.substring(start - 1, end);
                  let value = sub.trim();
                  if (value) {
                    const firstNonSpace = sub.search(/\S/) >= 0 ? sub.search(/\S/) : 0;
                    const displayLength = value.length; // Original length for highlighting

                    // Handle trailing negatives for data extraction
                    if (config.dataType === 'NUMBER' || config.dataType === 'CURRENCY') {
                      if (end < line.length && /[\u002D\u2212\u2013\u2014]/.test(line[end])) {
                        value += line[end]; // Extract the negative
                        // BUT keep displayLength as original for clean highlighting
                      }
                    }

                    value = handleTrailingNegative(value);

                    // Validation after handling
                        if ((config.dataType === 'NUMBER' || config.dataType === 'CURRENCY') && !value.replace(/,/g, '').match(/^-?\d+\.?\d*$/)) {
                      currentPos += line.length + 1;
                      return;
                    }

                    const startIndex = currentPos + (start - 1) + firstNonSpace;
                    matches.push({ 
                      value, 
                      fullMatch: line, 
                      startIndex,
                      length: displayLength, // Use original length for highlighting
                      lineNumber: idx + 1 
                    });
                  }
                }
              }
              currentPos += line.length + 1;
            });
          } else if (config.ruleType === 'SINGLE') {
            const regex = new RegExp(config.pattern.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gi');
            let match;
            while ((match = regex.exec(processingContent)) !== null && totalIterations < maxIterations) {
              totalIterations++;
              const fullMatch = match[0];
              const value = fullMatch;
              const startIndex = match.index;
              const length = value.length;
              matches.push({
                value,
                fullMatch,
                startIndex,
                length
              });
            }
          }
          
          console.log('üìà Found', matches.length, 'matches for:', fieldName);
          return matches;
        } catch (error) {
          console.error('‚ùå Error computing results for:', fieldName, error);
          console.error('Config:', config);
          console.error('Content length:', processingContent?.length || 0);
          
          // Return error result instead of crashing
          return [{ 
            error: 'Processing error: ' + error.message,
            value: 'Error',
            startIndex: 0,
            length: 0
          }];
        }
      };

      // Helper to apply a template by creating rules with fresh testResults
      const applyTemplate = (template) => {

        if (!fileContent) {
          alert('Please load a document first');
          return;
        }

        setIsApplyingTemplate(true); // <--- SET TO TRUE HERE

        // Apply column mapping if present in template
        if (template.columnMapping && template.columnMapping.version === 1 && 
            template.columnMapping.smartSpec && 
            template.columnMapping.smartSpec.boundaries && 
            Array.isArray(template.columnMapping.smartSpec.boundaries) &&
            template.columnMapping.smartSpec.boundaries.length > 0) {
          setColumnMappingSpec({
            source: 'manual',
            boundaries: template.columnMapping.smartSpec.boundaries.map(b => ({
              id: b.id || `col_${b.start}_${b.end}_${Date.now()}`,
              start: b.start,
              end: b.end
            }))
          });
          setColumnMappings(template.columnMapping.mapped || []);
          setColumnMappingEnabled(true);
        } else {
          // Clear column mapping if template doesn't have it or it's invalid
          setColumnMappingSpec(null);
          setColumnMappings([]);
          setColumnMappingEnabled(false);
        }

        // --- COMMON LOGIC ---
        const tempExcludePatterns = template.excludePatterns || [];

        const tempIsLineExcluded = (line) => {
          return tempExcludePatterns.some(pattern => wouldLineBeExcluded(line, pattern));
        };

        const createRuleFromConfig = (config, idx, hierarchySettings = null) => {
          const fieldName = config.fieldName || `Rule ${idx + 1}`;

          const tempResults = [];

          const newRule = {
            id: Date.now() + idx,
            fieldName: config.fieldName,
            type: config.ruleType,
            extractionType: config.ruleType,
            ruleType: config.ruleType,
            dataType: config.dataType,
            text: config.pattern,
            pattern: config.pattern,
            description: config.description,
            data: tempResults.filter(r => !r.error).map(r => r.value),
            testResults: tempResults.filter(r => !r.error),
            created: new Date().toISOString(),
            preserveEmpty: true
          };

          // Set the level based on the template config
          newRule.level = config.level || 'primary'; // Default to primary if 'level' is missing

          // Add append-specific properties ONLY if it's an append level
          if (newRule.level === 'append') {
            newRule.primaryRuleId = config.primaryRuleId; // Will be undefined, but that's fine
            newRule.scope = config.scope || 'proximity';
            newRule.onEmpty = config.onEmpty || 'empty'; // Default to 'empty'
          }

          return newRule;
        };

        // BATCH UPDATE STATE
        setExcludePatterns(tempExcludePatterns);
        console.log('üö´ Applying', tempExcludePatterns.length, 'exclusion patterns');

        setTimeout(() => {
          if (template.templateType === 'hierarchy' && template.hierarchy) {
            const tempSettings = template.hierarchy.settings || {};
            const newStack = template.hierarchy.stack.map((levelConfig, levelIdx) => {
              const newLevelRules = (levelConfig.rules || []).map((ruleConfig, ruleIdx) => {
                return createRuleFromConfig(ruleConfig, levelIdx * 1000 + ruleIdx, { mode: true, identifier: tempSettings.primaryLineIdentifier });
              });

              return {
                ...levelConfig,
                rules: newLevelRules
              };
            });

            const newSettings = template.hierarchy.settings || {};

            setHierarchyMode(true);
            setShowHierarchyView(true);
            setPrimaryLineIdentifier(newSettings.primaryLineIdentifier || '');
            setHierarchyStack(newStack);
            setRules([]); // Clear simple rules

            // 1. Get all rules (from hierarchy or simple template)
            const allRules = newStack.flatMap(l => l.rules);
            
            // 2. Get hierarchy settings
            const hierarchySettings = template.hierarchy.settings || {};
            
            // 3. Send all rules to worker for highlight computation
            if (worker && allRules.length > 0) {
              // Use template's columnMapping directly instead of state (state updates are async)
              const templateColumnMapping = template.columnMapping && template.columnMapping.version === 1 && 
                template.columnMapping.smartSpec && template.columnMapping.smartSpec.boundaries &&
                Array.isArray(template.columnMapping.smartSpec.boundaries) &&
                template.columnMapping.smartSpec.boundaries.length > 0
                ? {
                    spec: {
                      source: 'manual',
                      boundaries: template.columnMapping.smartSpec.boundaries.map(b => ({
                        id: b.id || `col_${b.start}_${b.end}_${Date.now()}`,
                        start: b.start,
                        end: b.end
                      }))
                    },
                    mappings: template.columnMapping.mapped || []
                  }
                : null;
              
              worker.postMessage({ 
                type: 'COMPUTE_TEST_RESULTS', 
                data: { 
                  fileContent: debouncedFileContent, 
                  rules: allRules, 
                  excludePatterns: tempExcludePatterns, 
                  hierarchySettings: { 
                    mode: true, 
                    identifier: hierarchySettings.primaryLineIdentifier,
                    columnPositions: columnPositions, // Pass column positions
                    columnMapping: templateColumnMapping
                  } 
                } 
              });
            } else {
              console.warn('‚ö†Ô∏è Worker not found or no rules to process.');
              setIsApplyingTemplate(false);
            }

          } else {
            console.log('üìù Applying SIMPLE template...');

            const newRules = (template.rules || []).map(createRuleFromConfig);

            setHierarchyMode(false);
            setShowHierarchyView(false);
            setHierarchyStack([]);
            setRules(newRules); // Set simple rules

            // 1. Get all rules (from hierarchy or simple template)
            const allRules = newRules;
            
            // 2. Get hierarchy settings
            const hierarchySettings = {};
            
            // 3. Send all rules to worker for highlight computation
            console.log(`MAIN: Sending ${allRules.length} rules to worker for highlight computation...`);
            if (worker && allRules.length > 0) {
              // Use template's columnMapping directly instead of state (state updates are async)
              const templateColumnMapping = template.columnMapping && template.columnMapping.version === 1 && 
                template.columnMapping.smartSpec && template.columnMapping.smartSpec.boundaries &&
                Array.isArray(template.columnMapping.smartSpec.boundaries) &&
                template.columnMapping.smartSpec.boundaries.length > 0
                ? {
                    spec: {
                      source: 'manual',
                      boundaries: template.columnMapping.smartSpec.boundaries.map(b => ({
                        id: b.id || `col_${b.start}_${b.end}_${Date.now()}`,
                        start: b.start,
                        end: b.end
                      }))
                    },
                    mappings: template.columnMapping.mapped || []
                  }
                : null;
              
              worker.postMessage({ 
                type: 'COMPUTE_TEST_RESULTS', 
                data: { 
                  fileContent: debouncedFileContent, 
                  rules: allRules, 
                  excludePatterns: tempExcludePatterns, 
                  hierarchySettings: { 
                    mode: false, 
                    identifier: '',
                    columnPositions: columnPositions, // Pass column positions
                    columnMapping: templateColumnMapping
                  } 
                } 
              });
            } else {
              console.warn('‚ö†Ô∏è Worker not found or no rules to process.');
              setIsApplyingTemplate(false);
            }
          }
        }, 50);
      };

      // Compute highlighted content (optimized for large files)
      const highlightedContent = useMemo(() => {
        if (!highlightsEnabled || !debouncedFileContent) {
          return escapeHtml(debouncedFileContent);
        }
        
        // For very large files (>10k lines), disable full highlighting to improve performance
        if (filteredLines.length > 10000) {
          return escapeHtml(debouncedFileContent);
        }

        let events = [];

        // Get all rules to highlight - include hierarchy stack rules if in hierarchy mode
        const allRulesForHighlighting = hierarchyMode && hierarchyStack.length > 0
          ? hierarchyStack.flatMap(level => level.rules || [])
          : debouncedRules;

        // Add extraction rule highlights
        allRulesForHighlighting.forEach(rule => {
          if (rule.testResults) {
            rule.testResults.forEach(result => {
              // Skip highlighting for empty values to prevent visual glitches
              if (result.isEmpty) return;
              
              if (result.startIndex !== undefined && result.length !== undefined) {
                // Check for append level first, then fall back to ruleType
                let className = `match-${rule.ruleType.toLowerCase()}`; // Default
                if (rule.level === 'append') {
                  className = 'match-append'; // Override for append rules
                }

                const tooltip = `title="${escapeHtml(`${rule.fieldName}: ${result.value}`)}"`;
                events.push({
                  pos: result.startIndex,
                  type: 'open',
                  tag: `<span class="${className}" data-rule-id="${rule.id}" ${tooltip}>`
                });
                events.push({ 
                  pos: result.startIndex + result.length, 
                  type: 'close', 
                  tag: '</span>' 
                });
              }
            });
          }
        });

        // Add exclusion highlights
        if (excludePatterns.length > 0) {
          // Use cached filteredLines instead of splitting again
          const lines = filteredLines;
          let currentPos = 0;
          
          lines.forEach((line, idx) => {
            if (isLineExcluded(line)) {
              // Highlight the entire line content (excluding leading/trailing whitespace for cleaner display)
              const trimmed = line.trim();
              if (trimmed) {
                const firstNonSpace = line.search(/\S/);
                const lastNonSpace = line.search(/\S\s*$/);
                const startIndex = currentPos + (firstNonSpace >= 0 ? firstNonSpace : 0);
                const endIndex = currentPos + (lastNonSpace >= 0 ? lastNonSpace + 1 : line.length);
                const length = endIndex - startIndex;
                
                events.push({
                  pos: startIndex,
                  type: 'open',
                  tag: `<span class="match-excluded" title="Excluded header: ${escapeHtml(trimmed)}">`
                });
                events.push({
                  pos: startIndex + length,
                  type: 'close', 
                  tag: '</span>'
                });
              }
            }
            currentPos += line.length + 1; // +1 for newline
          });
        }

        // Sort events: by position, closes before opens at same pos
        events.sort((a, b) => a.pos - b.pos || (a.type === 'close' ? -1 : 1));

        let highlighted = '';
        let prevPos = 0;

        events.forEach(event => {
          if (prevPos < event.pos) {
            highlighted += escapeHtml(debouncedFileContent.slice(prevPos, event.pos));
          }
          highlighted += event.tag;
          prevPos = event.pos;
        });

        highlighted += escapeHtml(debouncedFileContent.slice(prevPos));

        return highlighted;
      }, [highlightsEnabled, debouncedFileContent, debouncedRules, excludePatterns, filteredLines, linePositions, hierarchyMode, hierarchyStack]);

      // Add event listeners for highlight interactions (using event delegation for virtualized content)
      useEffect(() => {
        const container = docRef.current;
        if (container) {
          const handleMouseOver = (e) => {
            const span = e.target.closest('span[class^="match-"]');
            if (span && span.dataset && span.dataset.ruleId) {
              setActiveRuleId(parseInt(span.dataset.ruleId));
            }
          };

          const handleMouseOut = (e) => {
            const span = e.target.closest('span[class^="match-"]');
            if (span) {
            setActiveRuleId(null);
            }
          };

          // Use event delegation to handle dynamically rendered virtualized content
          container.addEventListener('mouseover', handleMouseOver);
          container.addEventListener('mouseout', handleMouseOut);

          return () => {
            container.removeEventListener('mouseover', handleMouseOver);
            container.removeEventListener('mouseout', handleMouseOut);
          };
        }
      }, []);

      // Detect fixed-width column positions from dashes line
      const columnPositions = useMemo(() => {
        // 1) Manual mapping (overlay) takes precedence when enabled
        if (columnMappingEnabled && columnMappingSpec?.boundaries?.length) {
          // Overlay boundaries are 1-based inclusive; extraction expects 0-based inclusive
          return columnMappingSpec.boundaries
            .slice() // defensive copy
            .sort((a, b) => a.start - b.start)
            .map(b => ({
              start: Math.max(0, (b.start ?? 1) - 1),
              end:   Math.max(0, (b.end   ?? b.start) - 1),
              isMerged: false
            }));
        }

        // 2) Existing Smart Columns (dash-based or spacing fallback)
        if (!debouncedFileContent) return null;

        // Use cached filteredLines instead of splitting again
        const lines = filteredLines;
        const dashIndex = lines.findIndex(line => /^\s*-+\s+-+/.test(line) && [...line.matchAll(/-+/g)].length > 3);
        if (dashIndex === -1) return null;

        const mainHeader = lines[dashIndex - 1];
        const wordStarts = [...mainHeader.matchAll(/\S+/g)].map(m => m.index);

        const columns = [];
        const dashLine = lines[dashIndex];
        const matches = [...dashLine.matchAll(/-+/g)];

        matches.forEach(match => {
          const g_start = match.index;
          const g_length = match[0].length;
          const g_end = g_start + g_length - 1;
          const w_list = wordStarts.filter(w => g_start <= w && w <= g_end).sort((a, b) => a - b);
          const isMerged = w_list.length > 1;
          columns.push({
            start: g_start,
            end: g_end,
            isMerged
          });
        });

        return columns;
      }, [columnMappingEnabled, columnMappingSpec, filteredLines, debouncedFileContent]);

      // Helper function to resolve column identifier (number or name) to column index
      const resolveColumnIndex = useCallback((columnIdentifier) => {
        // Remove quotes if present (e.g., "Inv Date" -> Inv Date)
        let identifier = columnIdentifier.trim();
        if ((identifier.startsWith('"') && identifier.endsWith('"')) || 
            (identifier.startsWith("'") && identifier.endsWith("'"))) {
          identifier = identifier.slice(1, -1).trim();
        }
        
        // If it's already a number, return it
        const num = parseInt(identifier);
        if (!isNaN(num) && num.toString() === identifier) {
          return num;
        }
        
        // Otherwise, treat it as a field name and look it up
        if (columnMappingEnabled && columnMappingSpec?.boundaries?.length && columnMappings?.length) {
          // Find the mapping with this field name (case-insensitive, trimmed)
          const normalizedName = identifier.toLowerCase().trim();
          const mapping = columnMappings.find(m => 
            m.fieldName && m.fieldName.toLowerCase().trim() === normalizedName
          );
          
          if (mapping) {
            // Find the index of this columnId in the sorted boundaries
            const sortedBoundaries = [...columnMappingSpec.boundaries].sort((a, b) => a.start - b.start);
            const index = sortedBoundaries.findIndex(b => b.id === mapping.columnId);
            if (index >= 0) {
              return index + 1; // Return 1-based index
            }
          }
        }
        
        // If not found, return null
        return null;
      }, [columnMappingEnabled, columnMappingSpec, columnMappings]);

      const testPattern = useCallback(() => {
        if (!pattern || !debouncedFileContent) {
          setTestResults([]);
          setIsTestingPattern(false);
          return;
        }
        
        setIsTestingPattern(true);

        // Determine hierarchy context for filtering lines
        let currentRuleLevel = 'primary'; // Default fallback
        let primaryLineRegex = null;

        if (hierarchyMode && primaryLineIdentifier) {
          // Determine the current rule level based on selectedHierarchyLevel
          if (selectedHierarchyLevel === 'new-detail' || selectedHierarchyLevel === 'new-footer') {
            currentRuleLevel = 'primary';
          } else if (selectedHierarchyLevel === 'new-append') {
            currentRuleLevel = 'append';
          } else if (selectedHierarchyLevel) {
            // It's an ID, find the level in hierarchyStack
            const foundLevel = hierarchyStack.find(l => l.id === selectedHierarchyLevel);
            if (foundLevel) {
              currentRuleLevel = foundLevel.type === 'detail' || foundLevel.type === 'footer' ? 'primary' : 'append';
            }
          }

          // Compile primary line regex
          try {
            primaryLineRegex = new RegExp(primaryLineIdentifier);
          } catch (error) {
            console.warn('Invalid primaryLineIdentifier regex:', primaryLineIdentifier, error);
            primaryLineRegex = /(?!)/; // Non-matching regex as fallback
          }
        }

        try {
          let matches = [];
          
          if (ruleType === 'PATTERN') {
            const regex = new RegExp(pattern, 'gim');
            let match;

            if (!hierarchyMode || !primaryLineRegex) {
              // Original logic for non-hierarchy mode
              const contentToUse = debouncedFileContent;
              let matchCount = 0;

              while ((match = regex.exec(contentToUse)) !== null) {
                const fullMatch = match[0];
                const value = match[1] !== undefined ? match[1] : fullMatch;
                const fullIndex = match.index;
                const valueOffset = fullMatch.indexOf(value);
                const startIndex = fullIndex + valueOffset;
                const length = value.length;
                matches.push({
                  value,
                  fullMatch,
                  startIndex,
                  length
                });
                matchCount++;
              }
            } else {
              // Hierarchy-aware logic: filter lines before testing
              const lines = filteredLines;
              let currentPos = 0;

              lines.forEach((line, idx) => {
                if (isLineExcluded(line)) {
                  currentPos += line.length + 1;
                  return;
                }

                // Apply hierarchy filter
                const isPrimaryLine = primaryLineRegex.test(line);
                if (currentRuleLevel === 'primary' && !isPrimaryLine) {
                  currentPos += line.length + 1;
                  return;
                }
                if (currentRuleLevel === 'append' && isPrimaryLine) {
                  currentPos += line.length + 1;
                  return;
                }

                // Test regex on this single line
                let lineMatch;
                const lineRegex = new RegExp(pattern, 'gim');
                while ((lineMatch = lineRegex.exec(line)) !== null) {
                  const fullMatch = lineMatch[0];
                  const value = lineMatch[1] !== undefined ? lineMatch[1] : fullMatch;
                  const lineStartIndex = lineMatch.index;
                  const valueOffset = fullMatch.indexOf(value);
                  const startIndexInLine = lineStartIndex + valueOffset;
                  const documentStartIndex = currentPos + startIndexInLine;
                  const length = value.length;

                  matches.push({
                    value,
                    fullMatch,
                    startIndex: documentStartIndex,
                    length
                  });
                }

                currentPos += line.length + 1;
              });
            }
          } else if (ruleType === 'POSITION') {

            // Use same content limiting for position rules as working version
            const contentToUse = filteredLines.length > 5000 ?
              filteredLines.slice(0, 1000).join('\n') :
              debouncedFileContent;
            const lines = contentToUse.split('\n');
            let currentPos = 0;
            lines.forEach((line, idx) => {
              if (isLineExcluded(line)) {
                currentPos += line.length + 1;
                return;
              }

              // Apply hierarchy filter if in hierarchy mode
              if (hierarchyMode && primaryLineRegex) {
                const isPrimaryLine = primaryLineRegex.test(line);
                if (currentRuleLevel === 'primary' && !isPrimaryLine) {
                  currentPos += line.length + 1;
                  return;
                }
                if (currentRuleLevel === 'append' && isPrimaryLine) {
                  currentPos += line.length + 1;
                  return;
                }
              }

              if (line.match(/^[-\s]*$/) || line.match(/^-{5,}/)) {
                currentPos += line.length + 1;
                return;
              }

              if (pattern.startsWith('line:')) {
                const lineNum = parseInt(pattern.split(':')[1]);
                if (idx + 1 === lineNum) {
                  let value = line.trim();
                  const firstNonSpace = line.search(/\S/);
                  const startIndex = currentPos + (firstNonSpace >= 0 ? firstNonSpace : 0);
                  const length = value.length;
                  if (value) {
                    matches.push({ 
                      value, 
                      fullMatch: line, 
                      startIndex, 
                      length,
                      lineNumber: idx + 1 
                    });
                  }
                }
              } else if (pattern.startsWith('column:')) {
                const columnSpec = pattern.split(':')[1].trim();

                if (columnSpec.includes('-')) {
                  // Range-based extraction: column:1-20 (character positions, not column names)
                  const [start, end] = columnSpec.split('-').map(n => parseInt(n));
                  
                  // --- START FIX ---
                  if (line.length >= start) {
                    // Line is long enough to potentially have a value
                    const sub = line.substring(start - 1, end);
                    let value = sub.trim();
                    
                    // Always create a match, even if empty, to maintain column alignment
                    let startIndex, displayLength;
                    
                    if (value && !value.match(/^[-\s]*$/)) {
                      // Non-empty value
                      const firstNonSpace = sub.search(/\S/);
                      startIndex = currentPos + (start - 1) + (firstNonSpace >= 0 ? firstNonSpace : 0);
                      displayLength = value.length;
                      
                      // Handle trailing negatives for data extraction
                      if (dataType === 'NUMBER' || dataType === 'CURRENCY') {
                        if (end < line.length && /[\u002D\u2212\u2013\u2014]/.test(line[end])) {
                          value += line[end]; // Extract the negative
                        }
                      }
                      value = handleTrailingNegative(value);
                      
                    } else {
                      // Empty value - highlight minimal position
                      value = '';
                      const rangeStart = Math.max(0, start - 1);
                      let actualStart = Math.min(rangeStart, line.length - 1);
                      if (actualStart < 0) actualStart = 0; // Handle completely empty lines
                      startIndex = currentPos + actualStart;
                      displayLength = 1;
                    }

                    matches.push({ 
                      value, 
                      fullMatch: line, 
                      startIndex, 
                      length: displayLength,
                      lineNumber: idx + 1,
                      isEmpty: value === ''
                    });
                  } else {
                    // Line is SHORTER than the start position.
                    // This is an empty match. Add it to the results.
                    matches.push({
                        value: '',
                        fullMatch: line,
                        startIndex: currentPos + Math.max(0, line.length - 1), // Highlight end of short line
                        length: 1, // Minimal highlight
                        lineNumber: idx + 1,
                        isEmpty: true
                    });
                  }
                  // --- END FIX ---

                } else {
                  // Smart column: Use fixed-width if detected, else fallback to split
                  // Support both numeric (column:1) and named (column:"Inv Date") references
                  const columnNum = resolveColumnIndex(columnSpec);
                  
                  if (columnNum === null) {
                    // Invalid column name or number, skip this line
                    currentPos += line.length + 1;
                    return;
                  }
                  
                  let value = '';
                  let startIndex;
                  let length;
                  let isEmpty = false;

                  if (columnPositions && columnPositions.length >= columnNum) {
                    // Fixed-width mode with proper empty column handling
                    const pos = columnPositions[columnNum - 1];
                    const sub = line.substring(pos.start, pos.end + 1);
                    value = sub.trim();
                    
                    if (pos.isMerged && value) {
                      if (dataType === 'TEXT' || dataType === 'DATE') {
                        value = value.replace(/\s{2,}.*$/, '').trim();
                      } else {
                        value = value.replace(/^.*\s{2,}/, '').trim();
                      }
                    }
                    
                    let displayLength, valuePos;
                    
                    if (value) {
                      // Non-empty value
                      valuePos = sub.indexOf(value);
                      if (valuePos < 0) {
                        valuePos = sub.search(/\S/) >= 0 ? sub.search(/\S/) : 0;
                      }
                      displayLength = value.length;

                      // Handle trailing negatives for data extraction
                      if (dataType === 'NUMBER' || dataType === 'CURRENCY') {
                        if (pos.end + 1 < line.length && /[\u002D\u2212\u2013\u2014]/.test(line[pos.end + 1])) {
                          value += line[pos.end + 1]; // Extract the negative
                          // BUT keep displayLength as original for clean highlighting
                        }
                      }

                      value = handleTrailingNegative(value);

                      // Validation after handling - if invalid, treat as empty but still include
                      if ((dataType === 'NUMBER' || dataType === 'CURRENCY') && !value.replace(/,/g, '').match(/^-?\d+\.?\d*$/)) {
                        value = '';
                        isEmpty = true;
                        // For invalid values, highlight first position of column
                        valuePos = 0;
                        displayLength = 1;
                      }
                    } else {
                      // Empty column - highlight minimal position
                      isEmpty = true;
                      valuePos = 0;
                      displayLength = 1;
                    }

                    startIndex = currentPos + pos.start + valuePos;
                    length = displayLength;
                    matches.push({ 
                      value, 
                      fullMatch: line, 
                      startIndex, 
                      length, 
                      lineNumber: idx + 1,
                      isEmpty
                    });
                  } else {
                    // Enhanced fallback split mode with empty column preservation
                    const originalColumns = line.split(/\s{2,}/);
                    const columns = originalColumns.map(col => col.trim());
                    
                    // Ensure we have enough columns (pad with empty if needed)
                    while (columns.length < columnNum) {
                      columns.push('');
                    }
                    
                    if (columns.length >= columnNum) {
                      value = columns[columnNum - 1] || '';
                      isEmpty = value === '';
                      
                      // Find position of this column in original line
                      let pos = 0;
                      let foundStart = -1;
                      
                      for (let c = 0; c < columnNum; c++) {
                        if (c < originalColumns.length && originalColumns[c]) {
                          const originalCol = originalColumns[c];
                          const found = line.indexOf(originalCol, pos);
                          if (found !== -1) {
                            if (c === columnNum - 1) {
                              // Found our target column
                              if (!isEmpty) {
                                foundStart = found + originalCol.indexOf(value);
                                if (foundStart < found) foundStart = found;
                              } else {
                                // Empty column - point to end of previous column or start of line
                                foundStart = found + originalCol.length;
                              }
                              break;
                            }
                            pos = found + originalCol.length;
                            // Skip whitespace
                            while (pos < line.length && /\s/.test(line[pos])) pos++;
                          }
                        } else if (c === columnNum - 1) {
                          // This is our target column but it doesn't exist in original
                          foundStart = Math.min(pos, line.length - 1);
                          isEmpty = true;
                          value = '';
                          break;
                        }
                      }
                      
                      if (!isEmpty) {
                        // Handle trailing negatives for data extraction
                        if (foundStart >= 0) {
                          const end = foundStart + value.length;
                          if (dataType === 'NUMBER' || dataType === 'CURRENCY') {
                            if (end < line.length && /[\u002D\u2212\u2013\u2014]/.test(line[end])) {
                              value += line[end]; // Extract the negative
                              // Keep original length for highlighting
                            }
                          }
                        }
                        
                        value = handleTrailingNegative(value);
                        
                        // Validation - if invalid, treat as empty but still include
                        if ((dataType === 'NUMBER' || dataType === 'CURRENCY') && !value.replace(/,/g, '').match(/^-?\d+\.?\d*$/)) {
                          value = '';
                          isEmpty = true;
                        }
                      }
                      
                      // Calculate highlighting parameters
                      let displayLength;
                      if (isEmpty) {
                        displayLength = 1; // Minimal highlight for empty values
                        // Ensure we don't go beyond line length
                        if (foundStart >= line.length) {
                          foundStart = Math.max(0, line.length - 1);
                        }
                      } else {
                        displayLength = columns[columnNum - 1].length; // Use original column length
                      }
                      
                      startIndex = currentPos + Math.max(0, foundStart);
                      length = displayLength;
                      matches.push({ 
                        value, 
                        fullMatch: line, 
                        startIndex, 
                        length, 
                        lineNumber: idx + 1,
                        isEmpty
                      });
                    }
                  }
                }
              } else if (pattern.startsWith('chars:')) {
                const [start, end] = pattern.split(':')[1].split('-').map(n => parseInt(n));
                if (line.length >= start) {
                  const sub = line.substring(start - 1, end);
                  let value = sub.trim();
                  if (value) {
                    const firstNonSpace = sub.search(/\S/) >= 0 ? sub.search(/\S/) : 0;
                    const displayLength = value.length; // Original length for highlighting

                    // Handle trailing negatives for data extraction
                    if (dataType === 'NUMBER' || dataType === 'CURRENCY') {
                      if (end < line.length && /[\u002D\u2212\u2013\u2014]/.test(line[end])) {
                        value += line[end]; // Extract the negative
                        // BUT keep displayLength as original for clean highlighting
                      }
                    }

                    value = handleTrailingNegative(value);

                    // Validation after handling
                    if ((dataType === 'NUMBER' || dataType === 'CURRENCY') && !value.replace(/,/g, '').match(/^-?\d+\.?\d*$/)) {
                      currentPos += line.length + 1;
                      return;
                    }

                    const startIndex = currentPos + (start - 1) + firstNonSpace;
                    matches.push({ 
                      value, 
                      fullMatch: line, 
                      startIndex,
                      length: displayLength, // Use original length for highlighting
                      lineNumber: idx + 1 
                    });
                  }
                }
              }
              currentPos += line.length + 1;
            });
          } else if (ruleType === 'SINGLE') {
            const escapedPattern = pattern.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');

            if (!hierarchyMode || !primaryLineRegex) {
              // Original logic for non-hierarchy mode
              const regex = new RegExp(escapedPattern, 'gi');
              let match;
              const contentToUse = debouncedFileContent;
              let matchCount = 0;

              while ((match = regex.exec(contentToUse)) !== null) {
                const fullMatch = match[0];
                const value = fullMatch;
                const startIndex = match.index;
                const length = value.length;
                matches.push({
                  value,
                  fullMatch,
                  startIndex,
                  length
                });
                matchCount++;
              }
            } else {
              // Hierarchy-aware logic: filter lines before testing
              const lines = filteredLines;
              let currentPos = 0;

              lines.forEach((line, idx) => {
                if (isLineExcluded(line)) {
                  currentPos += line.length + 1;
                  return;
                }

                // Apply hierarchy filter
                const isPrimaryLine = primaryLineRegex.test(line);
                if (currentRuleLevel === 'primary' && !isPrimaryLine) {
                  currentPos += line.length + 1;
                  return;
                }
                if (currentRuleLevel === 'append' && isPrimaryLine) {
                  currentPos += line.length + 1;
                  return;
                }

                // Test regex on this single line
                let lineMatch;
                const lineRegex = new RegExp(escapedPattern, 'gi');
                while ((lineMatch = lineRegex.exec(line)) !== null) {
                  const fullMatch = lineMatch[0];
                  const value = fullMatch;
                  const lineStartIndex = lineMatch.index;
                  const documentStartIndex = currentPos + lineStartIndex;
                  const length = value.length;

                  matches.push({
                    value,
                    fullMatch,
                    startIndex: documentStartIndex,
                    length
                  });
                }

                currentPos += line.length + 1;
              });
            }
          }
          
          setTestResults(matches);
          setIsTestingPattern(false);
        } catch (error) {
          setTestResults([{ error: 'Invalid pattern: ' + error.message }]);
          setIsTestingPattern(false);
        }
      }, [pattern, debouncedFileContent, ruleType, dataType, excludePatterns, columnPositions, hierarchyMode, primaryLineIdentifier, selectedHierarchyLevel, hierarchyStack, resolveColumnIndex]);

      // Removed automatic pattern testing to prevent freezing when opening rule builder
      // Pattern testing now only happens when user explicitly changes the pattern input

      // Save rule (create or update)
      const saveRule = (fieldNameInput, extractionTypeInput, dataTypeInput) => {
        const finalFieldName = fieldNameInput || fieldName || `Field ${rules.length + 1}`;
        const finalRuleType = extractionTypeInput || ruleType || 'SINGLE';
        const finalDataType = dataTypeInput || dataType || 'TEXT';
        const finalPattern = pattern || (currentSelection ? currentSelection.text : '');

        if (!finalPattern) return;

        const selectedLevel = hierarchyMode && selectedHierarchyLevel ?
          hierarchyStack.find(l => l.id === selectedHierarchyLevel) : null;

        // This logic now also handles the "new-append" case correctly
        const levelType = selectedLevel?.type || (selectedHierarchyLevel?.startsWith('new-') ? selectedHierarchyLevel.replace('new-', '') : null);

        // Create hierarchy context for full test results calculation
        // Include columnMapping and columnPositions only if column mapping is enabled (for column name resolution)
        const effectiveColumnMapping = columnMappingEnabled && columnMappingSpec ? {
          spec: columnMappingSpec,
          mappings: columnMappings
        } : null;
        
        const hierarchyContext = hierarchyMode ? {
          mode: true,
          identifier: primaryLineIdentifier,
          ...(effectiveColumnMapping ? { columnPositions: columnPositions, columnMapping: effectiveColumnMapping } : {})
        } : effectiveColumnMapping ? {
          mode: false,
          identifier: '',
          columnPositions: columnPositions,
          columnMapping: effectiveColumnMapping
        } : null;

        // Create temp rule config for full test results calculation
        const tempRuleConfig = {
          fieldName: finalFieldName,
          ruleType: finalRuleType,
          dataType: finalDataType,
          pattern: finalPattern,
          level: levelType === 'append' ? 'append' : 'primary'
        };

        // Re-calculate full test results (not limited like testPattern function)
        const fullTestResults = computeTestResultsSync(tempRuleConfig, isLineExcluded, hierarchyContext);

        const updatedRule = {
          id: editingRule ? editingRule.id : Date.now(),
          fieldName: finalFieldName,
          extractionType: finalRuleType,
          ruleType: finalRuleType,
          dataType: finalDataType,
          text: currentSelection?.text || finalPattern,
          pattern: finalPattern,
          description: ruleDescription,
          data: fullTestResults.filter(r => !r.error).map(r => r.value),
          testResults: fullTestResults.filter(r => !r.error),
          created: editingRule ? editingRule.created : new Date().toISOString(),
          preserveEmpty: editingRule ? editingRule.preserveEmpty : true,
          level: levelType === 'append' ? 'append' : 'primary'
        };

        // Add append-specific properties only if it's an append rule
        if (levelType === 'append') {
            updatedRule.type = 'regex'; // Default append rules to regex type
            updatedRule.scope = appendScope;
            updatedRule.onEmpty = appendOnEmpty;
        }

        console.log(editingRule ? 'üéØ Updating rule' : 'üéØ Creating rule', 'with', updatedRule.testResults.length, 'results');

        // Handle updating existing rule
        if (editingRule) {
          if (hierarchyMode) {
            // Update rule in hierarchy mode
            setHierarchyStack(prev => prev.map(level => {
              if (level.id === editingRule.levelId) {
                return { 
                  ...level, 
                  rules: level.rules.map(rule => 
                    rule.id === editingRule.id ? updatedRule : rule
                  )
                };
              }
              return level;
            }));
          } else {
            // Update rule in simple mode
            setRules(rules.map(rule => rule.id === editingRule.id ? updatedRule : rule));
          }
          
          // Reset editing state
          setEditingRule(null);
          setShowRuleBuilder(false);
          setCurrentSelection(null);
          setIsTestingPattern(false);
          setSelectedHierarchyLevel(null);
          
          // Trigger test results update
          setTimeout(() => testPattern(), 100);
          return;
        }

        // Handle creating new rule
        // Handle hierarchy mode with corrected state logic
        if (hierarchyMode && selectedHierarchyLevel) {
          let newStack;
          let allRules;
          
          if (selectedHierarchyLevel.startsWith('new-')) {
            // Case 1: Create a new level AND add the rule to it in one go
            const newLevelType = selectedHierarchyLevel.replace('new-', '');
            const newLevel = {
              id: `${newLevelType}-${Date.now()}`,
              type: newLevelType,
              name: `${newLevelType.charAt(0).toUpperCase() + newLevelType.slice(1)} Level`,
              rules: [updatedRule], // Add the new rule directly
              scope: { terminator: 'nextLevel', indentBreak: false, blankLines: 1 }
            };
            newStack = [...hierarchyStack, newLevel];
            allRules = newStack.flatMap(l => l.rules);
            setHierarchyStack(newStack);
          } else {
            // Case 2: Add the rule to an existing level
            newStack = hierarchyStack.map(level => {
              if (level.id === selectedHierarchyLevel) {
                return { ...level, rules: [...level.rules, updatedRule] };
              }
              return level;
            });
            allRules = newStack.flatMap(l => l.rules);
            setHierarchyStack(newStack);
          }

          // Reset UI state
          setShowRuleBuilder(false);
          setCurrentSelection(null);
          setIsTestingPattern(false);
          setSelectedHierarchyLevel(null);
          
          // Trigger test results computation for all rules (including the new one)
          setTimeout(() => {
            if (worker && allRules.length > 0) {
              worker.postMessage({ 
                type: 'COMPUTE_TEST_RESULTS', 
                data: { 
                  fileContent: debouncedFileContent, 
                  rules: allRules, 
                  excludePatterns: excludePatterns, 
                  hierarchySettings: {
                    mode: true, 
                    identifier: primaryLineIdentifier,
                    columnPositions: columnPositions,
                    columnMapping: columnMappingEnabled && columnMappingSpec ? {
                      spec: columnMappingSpec,
                      mappings: columnMappings
                    } : null
                  }
                } 
              });
            }
          }, 100);
          return;
        }

        // Fallback for non-hierarchy mode
        setRules([...rules, updatedRule]);
        setShowRuleBuilder(false);
        setCurrentSelection(null);
        setIsTestingPattern(false);
      };
      
      // Alias for backward compatibility
      const createRule = saveRule;

      // Enhanced data extraction with grouping support and empty value handling (optimized)
      const updateExtractedData = (rulesToApply, providedColumnMapping = null) => {
        if (isUpdatingData) {
          console.log('‚è≠Ô∏è Skipping data update - already in progress');
          return;
        }
        
        console.log('üîÑ Updating extracted data with', rulesToApply.length, 'rules');
        setIsUpdatingData(true);
        
        // Use provided columnMapping if available, otherwise fall back to state
        const effectiveColumnMapping = providedColumnMapping || 
          (columnMappingEnabled && columnMappingSpec ? {
            spec: columnMappingSpec,
            mappings: columnMappings
          } : null);
        
        // For large files with many potential matches, use Web Worker with chunking
        if (filteredLines.length > 5000 && worker && debouncedFileContent) {
          console.log('üöÄ Using Web Worker for large file extraction');
          setIsProcessing(true);
          tempExtractionDataRef.current = []; // Clear any previous temp data
          worker.postMessage({
            type: 'PROCESS_EXTRACTION',
            data: {
              fileContent: debouncedFileContent,
              rules: rulesToApply,
              excludePatterns: excludePatterns,
              columnMapping: effectiveColumnMapping
            }
          });
          return;
        }
        const primaryRules = rulesToApply;

        // Fallback to original logic for non-append rules
        if (!primaryRules.length) {
          setExtractedData([]);
          setIsUpdatingData(false);
          return;
        }

        // For data extraction, regenerate results with full content

        const rulesWithFullResults = primaryRules.map(rule => {
  
          // Use computeTestResultsForConfig with full content for final extraction
          const fullResults = rule.testResults || [];

          return {
            ...rule,
            testResults: fullResults.filter(r => !r.error),
            data: fullResults.filter(r => !r.error).map(r => r.value)
          };
        });

        // Process each rule's data to ensure consistent row counts
        const processedRules = rulesWithFullResults.map(rule => {
          // Only use testResults if they exist and have actual values
          // Never fall back to rule.text/pattern as that would show "column:1" etc.
          const data = (rule.testResults && rule.testResults.length > 0) ? 
            rule.testResults.map(result => result.value || '') : [];
          console.log('üìã Rule', rule.fieldName, 'has', data.length, 'data points');

          // CIRCUIT BREAKER: Skip extremely large datasets to prevent crash
          if (data.length > 5000) {
            console.warn('üî• CIRCUIT BREAKER: Rule', rule.fieldName, 'has', data.length, 'results - limiting to prevent crash');
            return {
              ...rule,
              processedData: data.slice(0, 1000) // Hard limit to first 1000 results
            };
          }

          return {
            ...rule,
            processedData: data
          };
        });
        
        // PERFORMANCE: Limit data if there are too many rows to prevent freeze
        const maxRowsForProcessing = 1000; // Very aggressive limit to prevent freezing

        // Check if any rule has multiple values
        const multiValueRules = processedRules.filter(r => r.processedData && r.processedData.length > 1);
        
        if (multiValueRules.length > 0) {
          // Create multiple rows - ensure all rules contribute to each row
          const maxRows = Math.max(...processedRules.map(r => r.processedData ? r.processedData.length : 1));
          const limitedMaxRows = Math.min(maxRows, maxRowsForProcessing);
          
          if (maxRows > maxRowsForProcessing) {
            console.warn(`‚ö†Ô∏è Limiting rows from ${maxRows} to ${maxRowsForProcessing} to prevent UI freeze`);
          }
          
          const rows = [];
          
          for (let i = 0; i < limitedMaxRows; i++) {
            const row = {};
            processedRules.forEach(rule => {
              const key = rule.fieldName;
              if (rule.processedData && rule.processedData.length > i) {
                // Use the specific value for this row
                row[key] = rule.processedData[i];
              } else if (rule.processedData && rule.processedData.length === 1) {
                // Single value rule - repeat for all rows
                row[key] = rule.processedData[0];
              } else {
                // No data available - use empty string to maintain structure
                row[key] = '';
              }
            });
            rows.push(row);
          }
          console.log('‚úÖ Setting extracted data:', rows.length, 'rows');
          // Use setTimeout to prevent blocking the UI thread
          setTimeout(() => {
            setExtractedData(rows);
            setIsUpdatingData(false);
          }, 10);
        } else {
          // Single row - but still preserve empty values
          const row = {};
          processedRules.forEach(r => {
            const key = r.fieldName;
            // Only use processedData, never fall back to rule.text/pattern
            row[key] = r.processedData?.[0] || '';
          });
          setExtractedData([row]);
        }
      };

      const splitDelimitedValues = (value) => {
        if (value === null || value === undefined) return [];
        const text = String(value).trim();
        if (!text) return [];
        const delimiter = text.includes(', ') ? ', ' : (text.includes(',') ? ',' : null);
        if (!delimiter) return [text];
        return text.split(delimiter).map(part => part.trim());
      };

      const expandAppendRows = (rows, appendFields) => {
        if (!appendFields.length) return rows;
        const expanded = [];
        rows.forEach(row => {
          const lists = appendFields.map(field => splitDelimitedValues(row[field]));
          const maxLen = Math.max(0, ...lists.map(list => list.length));
          const targetLen = maxLen > 0 ? maxLen : 1;

          for (let i = 0; i < targetLen; i += 1) {
            const nextRow = { ...row };
            appendFields.forEach((field, idx) => {
              const list = lists[idx];
              if (list.length === 0) {
                nextRow[field] = '';
              } else {
                nextRow[field] = list[i] !== undefined ? list[i] : '';
              }
            });
            expanded.push(nextRow);
          }
        });
        return expanded;
      };

      const expandedData = useMemo(() => {
        const baseData = hierarchyMode && hierarchyData.length > 0 ? hierarchyData : extractedData;
        if (!breakoutEnabled || appendFieldNames.length === 0 || baseData.length === 0) {
          return baseData;
        }
        return expandAppendRows(baseData, appendFieldNames);
      }, [breakoutEnabled, appendFieldNames, hierarchyMode, hierarchyData, extractedData]);

      const handleToggleBreakout = () => {
        if (!breakoutEnabled) {
          const baseData = hierarchyMode && hierarchyData.length > 0 ? hierarchyData : extractedData;
          if (baseData.length > 5000) {
            const proceed = window.confirm(
              `Breaking out sub-records may be slow for ${baseData.length.toLocaleString()} rows. Continue?`
            );
            if (!proceed) return;
          }
        }
        setBreakoutEnabled(prev => !prev);
      };

      // Export to CSV
      const exportToCSV = () => {
        if (!expandedData || expandedData.length === 0) return;

        const headers = Object.keys(expandedData[0]);
        const csvContent = [
          headers.join(','),
          ...expandedData.map(row =>
            headers.map(key => {
              let value = row[key] || '';
              if (typeof value === 'string') {
                value = value.replace(/"/g, '""');
              }
              return `"${value}"`;
            }).join(',')
          )
        ].join('\n');

        const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `extracted_data_${Date.now()}.csv`;
        a.click();
        URL.revokeObjectURL(url);
      };

      // Export templates to JSON
      const exportTemplates = (singleTemplate = null) => {
        const addColumnMapping = (template) => {
          // If template already has column mapping, preserve it
          if (template.columnMapping) {
            return template;
          }
          // Otherwise, add current column mapping if enabled
          if (columnMappingEnabled && columnMappingSpec?.boundaries?.length) {
            return {
              ...template,
              columnMapping: {
                version: 1,
                smartSpec: {
                  boundaries: columnMappingSpec.boundaries
                },
                mapped: columnMappings
              }
            };
          }
          return template;
        };

        if (singleTemplate) {
          // Export single template - wrap in array to match import format
          const templateWithMapping = addColumnMapping(singleTemplate);
          const sanitizedName = singleTemplate.name.replace(/[^a-z0-9]/gi, '_').toLowerCase();
          const blob = new Blob([JSON.stringify([templateWithMapping])], { type: 'application/json' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = `template_${sanitizedName}.json`;
          a.click();
          URL.revokeObjectURL(url);
          return;
        }

        // Export all templates
        if (!templates.length) return;
        const templatesWithMapping = templates.map(addColumnMapping);
        const blob = new Blob([JSON.stringify(templatesWithMapping)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'extraction_templates.json';
        a.click();
        URL.revokeObjectURL(url);
      };

      // Handle import templates
      const handleImportTemplates = (e) => {
        const file = e?.target?.files?.[0];
        if (!file) return;
        
        const reader = new FileReader();
        
        reader.onerror = () => {
          alert('Error reading file');
          resetFileInput(e);
        };
        
        reader.onload = (ev) => {
          try {
            const fileContent = ev.target?.result;
            if (!fileContent || fileContent.trim().length === 0) {
              alert('Error: File is empty');
              resetFileInput(e);
              return;
            }
            
            const imported = JSON.parse(fileContent);
            
            // Handle both single template object and array of templates
            const templatesToAdd = Array.isArray(imported) ? imported : [imported];
            
            // Validate templates structure
            if (!templatesToAdd || templatesToAdd.length === 0) {
              alert('Error: No templates found in file');
              resetFileInput(e);
              return;
            }
            
            const invalidTemplates = templatesToAdd.filter(t => !t || typeof t !== 'object' || !t.name);
            if (invalidTemplates.length > 0) {
              alert('Error: Invalid template structure. All templates must have a name property.');
              resetFileInput(e);
              return;
            }
            
            // Update templates
            setTemplates([...templates, ...templatesToAdd]);
            resetFileInput(e);
            
          } catch (err) {
            alert('Invalid JSON file');
            resetFileInput(e);
          }
        };
        
        reader.readAsText(file);
      };
      
      // Helper to reset file input
      const resetFileInput = (e) => {
        if (e?.target) {
          e.target.value = '';
        } else if (templateImportRef?.current) {
          templateImportRef.current.value = '';
        }
      };

      // Pre-fill rule builder modal when editing a rule
      useEffect(() => {
        if (showRuleBuilder && editingRule) {
          setFieldName(editingRule.fieldName || '');
          setRuleType(editingRule.ruleType || editingRule.extractionType || 'SINGLE');
          setDataType(editingRule.dataType || 'TEXT');
          setPattern(editingRule.pattern || editingRule.text || '');
          setRuleDescription(editingRule.description || '');
          // Preserve existing test results if available
          if (editingRule.testResults) {
            setTestResults(editingRule.testResults);
          }
          if (hierarchyMode) {
            setSelectedHierarchyLevel(editingRule.levelId || '');
            // Handle append-specific fields if editing an append rule
            const level = hierarchyStack.find(l => l.id === editingRule.levelId);
            if (level?.type === 'append' || editingRule.level === 'append' || editingRule.type === 'append') {
              setAppendScope(editingRule.scope || 'proximity');
              setAppendOnEmpty(editingRule.onEmpty || 'null');
            }
          }
          // Pattern test will be triggered automatically when pattern value changes via input handlers
        } else if (!showRuleBuilder && !editingRule) {
          // Reset form when closing modal without editing
          setFieldName('');
          setRuleType('SINGLE');
          setDataType('TEXT');
          setPattern('');
          setRuleDescription('');
          setSelectedHierarchyLevel(null);
          setAppendScope('proximity');
          setAppendOnEmpty('null');
          setTestResults([]);
        }
      }, [showRuleBuilder, editingRule, hierarchyMode, hierarchyStack]);

      // Keep preview in sync (debounced for performance)
      useEffect(() => {
        // --- GUARD IS NOW STRONGER ---
        if (hierarchyMode || isApplyingTemplate) {
          console.log(`üîî Skipping simple rule preview. (Hierarchy: ${hierarchyMode}, Applying: ${isApplyingTemplate})`);
          return;
        }
        // --- END MODIFICATION ---

        console.log('üîî Rules or data changed, updating preview with', debouncedRules.length, 'rules');
        // Small delay to ensure rules are fully processed
        setTimeout(() => {
          updateExtractedData(debouncedRules);
        }, 100);
      }, [debouncedRules, excludePatterns, hierarchyMode, isApplyingTemplate]); // <-- Add isApplyingTemplate

      // Recompute testResults for existing rules when document changes
      useEffect(() => {
        // --- ADD THIS GUARD ---
        if (hierarchyMode) {
          console.log('üîî Skipping simple rule auto-refresh, hierarchy mode is active.');
          return;
        }
        // --- END ADDITION ---

        if (debouncedFileContent && debouncedRules.length > 0 && !isAutoRefreshing && !isApplyingTemplate &&
            debouncedFileContent !== lastProcessedContentRef.current) {
          console.log('üîÑ Auto-refresh triggered for', debouncedRules.length, 'rules (content changed)');
          setIsAutoRefreshing(true);
          lastProcessedContentRef.current = debouncedFileContent;
          // Add small delay to prevent interference with template application
          const timeoutId = setTimeout(() => {
            setRules(currentRules => currentRules.map(rule => {
              console.log('üîß Auto-refreshing rule:', rule.fieldName || 'Unnamed Rule');
              const freshResults = computeTestResultsForConfig({
                pattern: rule.pattern,
                ruleType: rule.ruleType,
                dataType: rule.dataType,
                fieldName: rule.fieldName || 'Unnamed Rule', // Add fieldName for debugging
                level: rule.level // Pass level for hierarchy-aware filtering
              }, undefined, { mode: hierarchyMode, identifier: primaryLineIdentifier });

              return {
                ...rule,
                testResults: freshResults.filter(r => !r.error),
                data: freshResults.filter(r => !r.error).map(r => r.value)
              };
            }));
            console.log('‚úÖ Auto-refresh complete');
            setIsAutoRefreshing(false);
          }, 100); // Small delay to prevent double-processing

          return () => {
            clearTimeout(timeoutId);
            setIsAutoRefreshing(false);
          };
        }
      }, [debouncedFileContent, hierarchyMode]); // <-- Add hierarchyMode to dependency array

      // Render preview table
      const renderPreviewTable = () => {

        if (!showPreview) return null;

        // Use hierarchy data if in hierarchy mode, otherwise use regular extracted data
        const baseData = hierarchyMode && hierarchyData.length > 0 ? hierarchyData : extractedData;
        const dataSource = expandedData;
        const breakoutActive = breakoutEnabled && appendFieldNames.length > 0 && baseData.length > 0;

        if (!dataSource.length) {
          const message = hierarchyMode ?
            "No hierarchy data yet. Process your hierarchy stack first." :
            "No extracted data yet. Create a rule first.";
          return (
            <div className="text-sm text-gray-500 py-8 text-center">{message}</div>
          );
        }

        const headers = Object.keys(dataSource[0] || {});
        // Only render limited rows to prevent freezing
        const displayData = dataSource.slice(0, maxPreviewRows);
        
        return (
          <>
            <div className="flex justify-between items-center mb-4">
              <span className="text-sm font-medium text-gray-700">
                {hierarchyMode ? 'Hierarchy' : 'Extracted'} Data ({dataSource.length.toLocaleString()} rows)
                {breakoutActive && dataSource.length !== baseData.length && (
                  <span className="text-xs text-gray-500 ml-2">
                    (breakout from {baseData.length.toLocaleString()} rows)
                  </span>
                )}
                {dataSource.length > maxPreviewRows && (
                  <span className="text-xs text-gray-500 ml-2">
                    (showing first {maxPreviewRows} for performance)
                  </span>
                )}
              </span>
              <div className="flex items-center gap-3">
                {hierarchyMode && appendFieldNames.length > 0 && (
                  <button
                    onClick={handleToggleBreakout}
                    className={`text-sm px-3 py-2 rounded transition-colors ${
                      breakoutEnabled
                        ? 'bg-blue-600 text-white hover:bg-blue-700'
                        : 'bg-gray-200 text-gray-700 hover:bg-gray-300'
                    }`}
                  >
                    üß© Break out sub-records {breakoutEnabled ? 'On' : 'Off'}
                  </button>
                )}
                <button onClick={exportToCSV} className="text-sm bg-green-600 text-white px-4 py-2 rounded hover:bg-green-700 transition-colors">
                  üì• Export CSV
                </button>
              </div>
            </div>
            
            <div className="overflow-auto border rounded max-h-96">
              <table className="min-w-full text-left">
                <thead className="sticky top-0 bg-gray-50">
                  <tr>
                    {headers.map(h => <th key={h} className="px-4 py-3 border-b font-medium text-gray-700 text-sm">{h}</th>)}
                  </tr>
                </thead>
                <tbody>
                  {displayData.map((row, idx) => (
                    <tr key={idx} className="odd:bg-white even:bg-gray-50 hover:bg-blue-50 transition-colors">
                      {headers.map(h => (
                        <td key={h} className="px-4 py-2 text-sm border-b border-gray-100">
                          {row[h] ? row[h] : <span className="text-gray-400 italic text-xs">(empty)</span>}
                        </td>
                      ))}
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>
          </>
        );
      };

      // HierarchyView component
      const HierarchyView = () => {
        const [draggedItem, setDraggedItem] = useState(null);
        const [dragOverIndex, setDragOverIndex] = useState(null);

        const handleDragStart = (e, index) => {
          setDraggedItem(index);
          e.dataTransfer.effectAllowed = 'move';
        };

        const handleDragOver = (e, index) => {
          e.preventDefault();
          setDragOverIndex(index);
        };

        const handleDrop = (e, dropIndex) => {
          e.preventDefault();
          if (draggedItem !== null && draggedItem !== dropIndex) {
            moveHierarchyLevel(draggedItem, dropIndex);
          }
          setDraggedItem(null);
          setDragOverIndex(null);
        };

        const handleDragEnd = () => {
          setDraggedItem(null);
          setDragOverIndex(null);
        };

        const renderLevelCard = (level, index) => {
          const isDraggedOver = dragOverIndex === index;
          const isDragging = draggedItem === index;

          return (
            <div
              key={level.id}
              draggable
              onDragStart={(e) => handleDragStart(e, index)}
              onDragOver={(e) => handleDragOver(e, index)}
              onDrop={(e) => handleDrop(e, index)}
              onDragEnd={handleDragEnd}
              className={`
                border rounded-lg p-4 mb-3 cursor-move transition-all
                ${level.type === 'detail' ? 'border-blue-300 bg-blue-50' :
                  level.type === 'append' ? 'border-green-300 bg-green-50' :
                  'border-gray-300 bg-gray-50'}
                ${isDragging ? 'opacity-50' : ''}
                ${isDraggedOver ? 'border-purple-500 border-dashed' : ''}
              `}
            >
              <div className="flex items-center justify-between mb-3">
                <div className="flex items-center gap-2">
                  <span className="text-lg">
                    {level.type === 'detail' ? 'üìã' : level.type === 'append' ? '‚ûï' : 'üìÑ'}
                  </span>
                  <div>
                    <h3 className="font-semibold text-sm">{level.name}</h3>
                    <span className="text-xs text-gray-600">
                      {level.type} ‚Ä¢ {level.rules.length} rules
                    </span>
                  </div>
                </div>
                <div className="flex gap-1">
                  <button
                    onClick={() => updateHierarchyLevel(level.id, {
                      name: prompt('Enter new name:', level.name) || level.name
                    })}
                    className="text-xs px-2 py-1 bg-gray-200 rounded hover:bg-gray-300"
                  >
                    ‚úèÔ∏è
                  </button>
                  <button
                    onClick={() => removeHierarchyLevel(level.id)}
                    className="text-xs px-2 py-1 bg-red-200 text-red-700 rounded hover:bg-red-300"
                  >
                    üóëÔ∏è
                  </button>
                </div>
              </div>

              <div className="space-y-2">
                {level.rules.length === 0 ? (
                  <div className="text-xs text-gray-500 italic py-2">
                    No rules in this level
                  </div>
                ) : (
                  level.rules.map((rule, ruleIndex) => (
                    <div key={rule.id || ruleIndex} className="flex items-center justify-between bg-white rounded p-2 text-xs">
                      <div className="flex items-center gap-2">
                        <span className="text-xs">
                          {rule.ruleType === 'APPEND' ? '‚Ü≥' : '‚Ä¢'}
                        </span>
                        <span className="font-medium">{rule.fieldName}</span>
                        <span className="text-gray-500">
                          ({RULE_TYPES[rule.ruleType]?.name || rule.ruleType})
                        </span>
                      </div>
                      <button
                        onClick={() => {
                          updateHierarchyLevel(level.id, {
                            rules: level.rules.filter((_, i) => i !== ruleIndex)
                          });
                        }}
                        className="text-red-500 hover:text-red-700 text-xs"
                      >
                        √ó
                      </button>
                    </div>
                  ))
                )}
              </div>

              {/* Scope settings removed to avoid confusion */}
            </div>
          );
        };

        return (
          <div className="bg-white border rounded-lg p-6">
            <div className="flex items-center justify-between mb-4">
              <h2 className="text-lg font-semibold flex items-center gap-2">
                üèóÔ∏è Hierarchy Builder
                <span className="text-sm font-normal text-gray-600">
                  ({hierarchyStack.length} levels)
                </span>
              </h2>
              <div className="flex gap-2">
                <button
                  onClick={() => addHierarchyLevel('detail')}
                  className="px-3 py-1 bg-blue-600 text-white text-sm rounded hover:bg-blue-700"
                >
                  + Detail Level
                </button>
                <button
                  onClick={() => addHierarchyLevel('append')}
                  className="px-3 py-1 bg-green-600 text-white text-sm rounded hover:bg-green-700"
                >
                  + Append Level
                </button>
                <button
                  onClick={() => addHierarchyLevel('footer')}
                  className="px-3 py-1 bg-gray-600 text-white text-sm rounded hover:bg-gray-700"
                >
                  + Footer Level
                </button>
              </div>
            </div>

            <div className="space-y-1">
              {hierarchyStack.length === 0 ? (
                <div className="text-center py-8 text-gray-500">
                  <div className="text-4xl mb-2">üèóÔ∏è</div>
                  <div className="text-sm">No hierarchy levels yet</div>
                  <div className="text-xs text-gray-400 mt-1">
                    Add levels above to start building your hierarchy
                  </div>
                </div>
              ) : (
                hierarchyStack.map((level, index) => renderLevelCard(level, index))
              )}
            </div>

            {hierarchyStack.length > 0 && (
              <div className="mt-6 pt-4 border-t border-gray-200">
                <div className="mb-4 space-y-2">
                  <div className="flex flex-col gap-1">
                    <label className="text-sm font-medium">Primary line identifier (regex):</label>
                    <div className="flex flex-col gap-2 sm:flex-row sm:items-center">
                      <input
                        type="text"
                        value={primaryLineIdentifier}
                        onChange={(e) => setPrimaryLineIdentifier(e.target.value)}
                        className="px-2 py-1 border rounded text-sm font-mono flex-1"
                        placeholder="^\\s*\\S+.*\\d{1,2}-\\d{1,2}-\\d{2}"
                      />
                      <button
                        onClick={() => setShowRegexAssistant(true)}
                        className="px-3 py-1 bg-purple-600 text-white text-sm rounded hover:bg-purple-700 transition-colors"
                      >
                        ü§ñ AI Generate Pattern
                      </button>
                    </div>
                    <span className="text-xs text-gray-500">(Regex pattern to identify lines that start new records)</span>
                  </div>
                  <div className="flex items-center gap-2 mt-2">
                    <input
                      type="checkbox"
                      id="showPrimaryHighlights"
                      checked={showPrimaryHighlights}
                      onChange={(e) => setShowPrimaryHighlights(e.target.checked)}
                      className="h-4 w-4 rounded border-gray-300 text-indigo-600 focus:ring-indigo-500"
                    />
                    <label htmlFor="showPrimaryHighlights" className="text-sm text-gray-700">Highlight Primary Records</label>
                  </div>
                </div>
                <div className="flex gap-3">
                  <button
                    onClick={() => {
                      // Process hierarchy
                      if (worker && hierarchyStack.length > 0) {
                        setIsProcessing(true);
                        worker.postMessage({
                          type: 'PROCESS_HIERARCHY',
                          data: {
                            fileContent: debouncedFileContent,
                            rules: hierarchyStack.flatMap(level => level.rules || []),
                            settings: {
                              primaryLineIdentifier: primaryLineIdentifier,
                              columnPositions: columnPositions,
                              columnMapping: columnMappingEnabled && columnMappingSpec ? {
                                spec: columnMappingSpec,
                                mappings: columnMappings
                              } : null
                            },
                            excludePatterns
                          }
                        });
                      }
                    }}
                    disabled={isProcessing || !debouncedFileContent}
                    className="px-4 py-2 bg-purple-600 text-white rounded hover:bg-purple-700 disabled:opacity-50"
                  >
                    {isProcessing ? 'üîÑ Processing...' : '‚ö° Process Hierarchy'}
                  </button>
                  <button
                    onClick={() => migrateFromHierarchy()}
                    className="px-4 py-2 border border-gray-300 rounded hover:bg-gray-100"
                  >
                    üîÑ Back to Simple Mode
                  </button>
                </div>
              </div>
            )}
          </div>
        );
      };

      // Double-click handler for document containers (used when column mapping is enabled)
      const handleDocumentDoubleClick = (e) => {
        if (!columnMappingEnabled) return;
        const el = e.currentTarget;
        const scrollingEl = findScrollingElement(el);
        const rect = el.getBoundingClientRect();
        
        // Account for horizontal scroll offset from the actual scrolling element
        const currentScrollLeft = scrollingEl ? (scrollingEl.scrollLeft || 0) : 0;
        const x = e.clientX - rect.left + currentScrollLeft;
        const atChar = Math.max(1, Math.round(x / charWidthPx) + 1);
        const id = `col_manual_${Date.now()}`;
        const newBoundary = { id, start: atChar, end: atChar + 1 };
        
        if (columnMappingSpec && columnMappingSpec.boundaries) {
          setColumnMappingSpec({
            ...columnMappingSpec,
            boundaries: normalizeAndInsert(columnMappingSpec.boundaries, newBoundary)
          });
        } else {
          setColumnMappingSpec({
            source: 'manual',
            boundaries: [newBoundary]
          });
        }
      };

      async function generateRegexPatterns(samples) {
        if (!samples || samples.trim().length < 20) {
          setRegexError("Please paste at least 5-10 example lines from your document.");
          return;
        }
        
        setIsGeneratingRegex(true);
        setRegexError(null);
        
        try {
          const appConfig = (typeof window !== 'undefined' && window.MonarchAbdicatorConfig) || {};
          const {
            apiBaseUrl,
            accessCode,
            regexAssistantModel,
            aiModel
          } = appConfig;
          const regexModel = regexAssistantModel || aiModel || "gpt-5-mini";
          
          if (!apiBaseUrl) {
            throw new Error("AI service not configured. Set apiBaseUrl in monarch-config.js.");
          }

          const headers = { "Content-Type": "application/json" };
          if (accessCode) {
            headers.Authorization = `Bearer ${accessCode}`;
          }

          const payload = {
            model: regexModel,
            response_format: { type: "json_object" },
            messages: [
                {
                  role: "system",
                  content: "You are a regex pattern generator. You MUST respond with valid JSON only, no markdown or explanations."
                },
                {
                  role: "user",
                  content: `You are analyzing document structure to identify primary record lines vs indented sub-records.

SAMPLE LINES:
${samples}

STEP 1 - ANALYZE THE STRUCTURE:
First, identify what makes primary records DIFFERENT from sub-records:
- Are primary records at column 0 while sub-records are indented?
- Do primary records have a unique data element (dates, IDs, keywords)?
- What pattern appears in ALL primary records but NO sub-records?

STEP 2 - FIND CONSISTENT FEATURES:
Look across ALL primary record examples and find what they have in common:
- Consistent keywords or labels that appear at the start?
- Consistent data patterns like dates (MM-DD-YY), IDs, or codes?
- Consistent positioning (always starting at column 0 with no indentation)?
- Note: There may be MULTIPLE primary record formats - they must ALL be matched!

STEP 3 - VALIDATE MENTALLY:
Before suggesting patterns, test them mentally against the SAMPLE LINES above:
‚úì Does this pattern match ALL primary records shown in the examples?
‚úì Does this pattern avoid ALL indented sub-records?
‚úì If there are multiple primary record formats (e.g., "000" and "001019-45"), does it handle both?

PATTERN DESIGN PRINCIPLES:

‚ö†Ô∏è CRITICAL: Base patterns on the ACTUAL SAMPLE LINES above, not generic examples.

Look for what's CONSISTENT:
- If all primary records contain dates ‚Üí match the date pattern you actually see
- If all primary records start with a specific keyword ‚Üí match that exact keyword
- If all primary records are at column 0 ‚Üí anchor with ^

Look for what's UNIQUE to primary records:
- Keywords that only appear in primary lines
- Data formats (dates, IDs) that only appear in primary lines  
- Structural differences (indentation, positioning)

EXAMPLE CONCEPTS to adapt (NOT to copy):
- If YOU see dates in primary records: match that date format (e.g., \\d{1,2}-\\d{1,2}-\\d{2} or \\d{2}/\\d{2}/\\d{4})
- If YOU see keywords in primary records: match those keywords (e.g., ^Customer:, ^PART:, ^Invoice)
- If YOU see primary records aren't indented: require non-whitespace at start (^\\S)

‚ö†Ô∏è DO NOT use these example patterns unless they actually appear in YOUR sample data.

VERIFICATION CHECKPOINT:
Before suggesting patterns, verify:
1. ‚úì I analyzed the ACTUAL sample lines provided above
2. ‚úì My patterns are based on text I SEE in those samples
3. ‚úì I am NOT just copying/modifying the example concepts
4. ‚úì I tested each pattern mentally against ALL sample lines

If you're copying examples, STOP and re-analyze the actual samples.

SIMPLICITY RULE:
- PREFER simple patterns that match what's consistent
- AVOID complex patterns that try to validate everything
- Start with minimum pattern needed, only add specificity if simple patterns create false matches

Generate 3 patterns from SIMPLEST to MOST SPECIFIC:
1. Broadest pattern based on the most obvious consistent feature
2. Pattern that adds one additional validation
3. Pattern with stricter validation (use only if needed to avoid false matches)

Respond with this EXACT structure:
{
  "patterns": [
    {"pattern": "simplest pattern based on YOUR samples", "confidence": "high", "explanation": "Matches lines with [feature you found]"},
    {"pattern": "adds one validation", "confidence": "medium", "explanation": "Also validates [additional feature]"},
    {"pattern": "most specific", "confidence": "low", "explanation": "Strictest validation"}
  ]
}

Remember: Your patterns MUST be based on the SAMPLE LINES provided above. Do not copy generic examples.`
                }
              ]
          };

          const response = await fetch(apiBaseUrl, {
            method: "POST",
            headers,
            body: JSON.stringify(payload)
          });

          if (!response.ok) {
            const errorData = await response.json().catch(() => ({}));
            throw new Error(errorData.error?.message || `API error: ${response.status}`);
          }

          const data = await response.json();
          const result = JSON.parse(data.choices?.[0]?.message?.content || '{}');
          
          if (!result.patterns || !Array.isArray(result.patterns)) {
            throw new Error("Invalid response format from AI");
          }
          
          const validatedPatterns = result.patterns.map(p => {
            try {
              const regex = new RegExp(p.pattern);
              
              // Test pattern against actual document lines
              const matchCount = filteredLines.filter(line => regex.test(line)).length;
              
              return {
                ...p,
                matchCount,
                isValid: true
              };
            } catch (e) {
              console.warn("Invalid regex pattern:", p.pattern, e);
              return {
                ...p,
                matchCount: 0,
                isValid: false,
                error: e.message
              };
            }
          }).filter(p => p.isValid);

          // Prioritize patterns that actually match more lines; ties broken by simplicity
          validatedPatterns.sort((a, b) => {
            if (b.matchCount !== a.matchCount) {
              return b.matchCount - a.matchCount;
            }
            return a.pattern.length - b.pattern.length;
          });

          if (validatedPatterns.length > 0) {
            validatedPatterns[0].confidence = 'high';
            validatedPatterns[0].explanation = `${validatedPatterns[0].explanation} (Best match count)`;
          }
          if (validatedPatterns.length > 1) {
            validatedPatterns[1].confidence = 'medium';
          }
          if (validatedPatterns.length > 2) {
            validatedPatterns[2].confidence = 'low';
          }
          
          if (validatedPatterns.length === 0) {
            throw new Error("No valid regex patterns were generated. Try providing clearer examples.");
          }
          
          setRegexSuggestions(validatedPatterns);
          setIsGeneratingRegex(false);
          
        } catch (error) {
          console.error("Regex generation failed:", error);
          setRegexError(error.message || "Failed to generate patterns. Please try again.");
          setIsGeneratingRegex(false);
          setRegexSuggestions([]);
        }
      }

      return (
        <div className="max-w-6xl mx-auto p-6 space-y-6">
          <h1 className="text-2xl font-bold text-gray-800 flex items-center gap-2">
            <FileText size={20}/> Advanced Document Rule Builder - Monarch Replacement
          </h1>

          {/* Upload controls */}
          {!fileContent && (
            <div className="bg-white p-8 rounded shadow text-center space-y-4">
              <div className="text-gray-500 mb-4">
                <div className="mb-4 flex justify-center">
                  <img 
                    src="Pixel Art Advantive Royal Throne.png" 
                    alt="Royal Throne" 
                    className="max-w-40 mx-auto"
                    style={{imageRendering: 'pixelated', imageRendering: '-moz-crisp-edges', imageRendering: 'crisp-edges'}}
                  />
                </div>
                <h2 className="text-xl font-semibold">Load Document</h2>
                <p>Upload text files or load sample data</p>
              </div>
              
              <input ref={fileInputRef} type="file" accept=".txt" className="hidden" onChange={handleFileUpload} />
              <button onClick={() => fileInputRef.current.click()} className="px-6 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 inline-flex items-center gap-2">
                <Upload size={18}/> Choose File
              </button>
              <button onClick={loadSample} className="px-6 py-2 border border-gray-300 rounded hover:bg-gray-100 inline-flex items-center gap-2">
                <Sparkles size={18}/> Load Sample Parts Report
              </button>
            </div>
          )}

          {/* Main interface */}
          {fileContent && (
            <>
              <div className="flex items-center gap-4">
                <span className="font-semibold truncate max-w-[240px]">{fileName}</span>
                <button onClick={() => setSelectionMode(!selectionMode)} className={`px-4 py-2 rounded text-sm flex items-center gap-2 ${selectionMode ? 'bg-blue-600 text-white' : 'bg-gray-200'}`}>
                  <MousePointer size={16}/> {selectionMode ? 'Selection ON' : 'Enable Selection'}
                </button>
                <button onClick={() => setExcludeMode(!excludeMode)} className={`px-4 py-2 rounded text-sm flex items-center gap-2 ${excludeMode ? 'bg-red-600 text-white' : 'bg-gray-200'}`}>
                  üö´ {excludeMode ? 'Mark Headers ON' : 'Mark Headers'}
                </button>
                <button onClick={() => {
                  if (!hierarchyMode && rules.length > 0) {
                    migrateToHierarchy();
                  } else if (hierarchyMode) {
                    migrateFromHierarchy();
                  } else {
                    setHierarchyMode(true);
                    setShowHierarchyView(true);
                  }
                }} className={`px-4 py-2 rounded text-sm flex items-center gap-2 ${hierarchyMode ? 'bg-purple-600 text-white' : 'bg-gray-200'}`}>
                  üèóÔ∏è {hierarchyMode ? 'Hierarchy ON' : 'Hierarchy Mode'}
                </button>
                <button onClick={() => { setFileContent(''); setRules([]); setExtractedData([]); setExcludePatterns([]); setShowExcludeOptions(false); setPendingExclusion(null); setHierarchyStack([]); setHierarchyMode(false); setShowHierarchyView(false); setHierarchyData([]); setBreakoutEnabled(false); }} className="ml-auto p-1 text-gray-500 hover:text-gray-700">
                  <XIcon size={18}/>
                </button>
              </div>

              {excludeMode && (
                <div className="bg-red-50 border border-red-200 p-3 rounded">
                  <div className="font-medium text-red-800 mb-1">üö´ Smart Header Exclusion Mode</div>
                  <div className="text-sm text-red-700">
                    Select any text in the document to exclude it as a header. You'll get options to exclude exact matches or create flexible patterns that handle page numbers, dates, and other variables automatically.
                  </div>
                </div>
              )}


              <div className="grid lg:grid-cols-4 gap-6 mt-4">
                {/* Document View - spans 3 columns */}
                <div className="lg:col-span-3 space-y-4">
                  <div className="bg-white rounded shadow relative">
                    <div className="px-4 py-3 border-b bg-gray-50 flex justify-between items-center">
                      <div>
                        <h3 className="font-semibold">Document Content</h3>
                        <span className="text-xs text-gray-500">
                          {filteredLines.length.toLocaleString()} lines 
                          {filteredLines.length > 5000 && ' (limited view)'}
                          {isProcessing && ' ‚Ä¢ Processing...'}
                        </span>
                      </div>
                      <div className="flex items-center gap-2">
                        {filteredLines.length > 5000 && (
                          <span className="text-xs bg-green-100 text-green-800 px-2 py-1 rounded">
                            ‚ö° Large File Mode
                          </span>
                        )}
                        <button onClick={() => setHighlightsEnabled(!highlightsEnabled)} className="text-sm text-blue-600 hover:underline">
                          {highlightsEnabled ? 'Hide Highlights' : 'Show Highlights'}
                          {highlightsEnabled && (
                            <span className="text-xs text-gray-500 ml-1">
                              (üü¢ extractions, üü° appends, üî¥ exclusions)
                            </span>
                          )}
                        </button>
                        <button onClick={() => setColumnMappingEnabled(!columnMappingEnabled)} className="text-sm text-purple-600 hover:underline">
                          üß≠ {columnMappingEnabled ? 'Hide Columns' : 'Column Mapping'}
                        </button>
                      </div>
                    </div>
                    <div className="overflow-auto max-h-96 select-text" onMouseUp={handleTextSelection}>
                      {filteredLines.length > 5000 ? (
                        // For very large files, use virtualized rendering for optimal performance
                        <div className="p-4">
                          <div className="bg-yellow-50 border border-yellow-200 rounded p-3 mb-4">
                            <div className="text-sm font-medium text-yellow-800">
                              ‚ö° Large File Detected ({filteredLines.length.toLocaleString()} lines)
                            </div>
                            <div className="text-xs text-yellow-700 mt-1">
                              Using custom virtualized rendering for optimal performance. All rules and exclusions work on the entire document.
                            </div>
                          </div>
                          <div 
                            id="doc-view-content" 
                            className="whitespace-pre font-mono text-sm bg-white border rounded select-text relative" 
                            onMouseUp={handleTextSelection}
                            onDoubleClick={columnMappingEnabled ? handleDocumentDoubleClick : undefined}
                          >
                            <List
                              height={400}
                              itemCount={filteredLines.length}
                              itemSize={20}
                              width="100%"
                              overscanCount={20}
                              itemData={{
                                lines: filteredLines,
                                rules: displayableRules,
                                settings: { primaryLineIdentifier },
                                showPrimaryHighlights,
                                hierarchyMode
                              }}
                            ref={docRef}
                            >
                              {(props) => <VirtualizedRow {...props} />}
                            </List>
                            <ColumnOverlay 
                              containerId="doc-view-content"
                              columnMappingEnabled={columnMappingEnabled}
                              columnMappingSpec={columnMappingSpec}
                              setColumnMappingSpec={setColumnMappingSpec}
                              columnMappings={columnMappings}
                              setColumnMappings={setColumnMappings}
                              selectedHandleId={selectedHandleId}
                              setSelectedHandleId={setSelectedHandleId}
                              charWidthPx={charWidthPx}
                              setCharWidthPx={setCharWidthPx}
                              filteredLines={filteredLines}
                            />
                          </div>
                        </div>
                      ) : (
                        // Use virtualized rendering for all files
                        <div className="p-4">
                          <div 
                            id="doc-view-content" 
                            className="whitespace-pre font-mono text-sm bg-white border rounded select-text relative" 
                            onMouseUp={handleTextSelection}
                            onDoubleClick={columnMappingEnabled ? handleDocumentDoubleClick : undefined}
                          >
                            {List ? (
                              <List
                                height={400}
                                itemCount={filteredLines.length}
                                itemSize={20}
                                width="100%"
                                overscanCount={20}
                                itemData={{
                                  lines: filteredLines,
                                  rules: displayableRules,
                                  settings: { primaryLineIdentifier },
                                  showPrimaryHighlights,
                                  hierarchyMode
                                }}
                                ref={docRef}
                              >
                                {(props) => <VirtualizedRow {...props} />}
                              </List>
                            ) : (
                              <div ref={docRef}>
                                <FallbackDocumentViewer lines={filteredLines} maxLines={filteredLines.length} />
                              </div>
                            )}
                            <ColumnOverlay 
                              containerId="doc-view-content"
                              columnMappingEnabled={columnMappingEnabled}
                              columnMappingSpec={columnMappingSpec}
                              setColumnMappingSpec={setColumnMappingSpec}
                              columnMappings={columnMappings}
                              setColumnMappings={setColumnMappings}
                              selectedHandleId={selectedHandleId}
                              setSelectedHandleId={setSelectedHandleId}
                              charWidthPx={charWidthPx}
                              setCharWidthPx={setCharWidthPx}
                              filteredLines={filteredLines}
                            />
                          </div>
                        </div>
                      )}
                      {(isProcessing || (isApplyingTemplate && filteredLines.length > 5000)) && (
                        <div className="absolute inset-0 bg-white bg-opacity-75 flex items-center justify-center">
                          <div className="text-center">
                            <div className="text-sm text-gray-600 mb-2">Processing large file...</div>
                            {processingProgress > 0 && (
                              <div className="text-xs text-gray-500">
                                <div className="w-48 bg-gray-200 rounded-full h-2 mb-1">
                                  <div 
                                    className="bg-blue-600 h-2 rounded-full transition-all duration-300" 
                                    style={{ width: `${processingProgress}%` }}
                                  ></div>
                                </div>
                                {processingProgress}% complete
                              </div>
                            )}
                          </div>
                        </div>
                      )}
                    </div>
                  </div>

                  {/* Data Preview - same width as document */}
                  <div className="bg-white rounded shadow">
                    <div className="px-4 py-3 border-b bg-gray-50 flex items-center justify-between">
                      <h3 className="font-semibold flex items-center gap-2">
                        <TableIcon size={16}/> Data Preview
                      </h3>
                      <button onClick={() => updateExtractedData(rules)} className="text-xs text-blue-600 hover:text-blue-800 underline">
                        Refresh
                      </button>
                    </div>
                    <div className="p-4">
                      {renderPreviewTable()}
                    </div>
                  </div>

                  {/* Hierarchy View - full width when enabled */}
                  {hierarchyMode && showHierarchyView && (
                    <div className="bg-white rounded shadow">
                      <div className="px-4 py-3 border-b bg-gray-50">
                        <HierarchyView />
                      </div>
                    </div>
                  )}
                </div>

                {/* Rules sidebar - spans 1 column */}
                <aside className="lg:col-span-1 space-y-4">
                  {/* Exclusion Patterns */}
                  {excludePatterns.length > 0 && (
                    <div className="bg-white p-4 rounded shadow">
                      <h3 className="font-semibold mb-3 flex items-center gap-2">üö´ Excluded Headers ({excludePatterns.length})</h3>
                      <div className="space-y-2">
                        {excludePatterns.map((pattern, idx) => (
                          <div key={idx} className="text-sm bg-red-50 py-2 px-3 rounded border border-red-200">
                            <div className="flex items-center justify-between mb-1">
                              <span className="font-medium text-red-800">
                                {pattern.isRegex ? 'üîç' : 'üìù'} {pattern.name}
                              </span>
                              <button 
                                onClick={() => setExcludePatterns(excludePatterns.filter((_, i) => i !== idx))}
                                className="text-red-500 hover:text-red-700"
                              >
                                <XIcon size={12}/>
                              </button>
                            </div>
                            <div className="text-xs text-red-700 mb-1">"{pattern.description}"</div>
                            {pattern.isRegex && (
                              <div className="text-xs text-red-600 font-mono bg-red-100 px-1 rounded">
                                /{pattern.pattern}/i
                              </div>
                            )}
                          </div>
                        ))}
                      </div>
                    </div>
                  )}

                  <div className="bg-white p-4 rounded shadow">
                    <h3 className="font-semibold mb-3 flex items-center gap-2"><ListIcon size={16}/> Rules ({displayableRules.length})</h3>
                    {displayableRules.length === 0 && (<p className="text-sm text-gray-500">No rules yet. Select text to create rules.</p>)}
                    <div className="space-y-2">
                      {displayableRules.map(r => (
                        <div key={r.id} className={`text-sm py-2 px-3 rounded border-l-4 transition-colors ${
                          r.testResults && r.testResults.length > 0 ? 'border-green-500 bg-green-50' : 'border-gray-300 bg-gray-50'
                        } ${activeRuleId === r.id ? 'highlight-active' : ''}`}>
                          <div className="flex items-center justify-between mb-1">
                            <span className="font-medium">{r.fieldName}</span>
                            <div className="flex gap-2 items-center">
                              <span 
                                className="cursor-pointer text-blue-500 hover:text-blue-700" 
                                onClick={() => {
                                  // Set all form state BEFORE opening modal to prevent flash of wrong state
                                  // This is especially important for large files where re-renders are expensive
                                  setFieldName(r.fieldName || '');
                                  setRuleType(r.ruleType || r.extractionType || 'SINGLE');
                                  setDataType(r.dataType || 'TEXT');
                                  setPattern(r.pattern || r.text || '');
                                  setRuleDescription(r.description || '');
                                  if (r.testResults) {
                                    setTestResults(r.testResults);
                                  }
                                  if (hierarchyMode) {
                                    setSelectedHierarchyLevel(r.levelId || '');
                                    const level = hierarchyStack.find(l => l.id === r.levelId);
                                    if (level?.type === 'append' || r.level === 'append' || r.type === 'append') {
                                      setAppendScope(r.scope || 'proximity');
                                      setAppendOnEmpty(r.onEmpty || 'null');
                                    }
                                  }
                                  // Now open the modal with correct state already set
                                  setEditingRule(r);
                                  setShowRuleBuilder(true);
                                }}
                                title="Edit rule"
                              >
                                ‚úèÔ∏è
                              </span>
                              {/* Note: Deleting rules from the sidebar in hierarchy mode needs a different function,
                                  but for now, this will at least show them. We'll disable deletion in hierarchy mode. */}
                              {!hierarchyMode && (
                                <XIcon size={14} className="cursor-pointer text-red-500 hover:text-red-700" onClick={() => setRules(rules.filter(x => x.id !== r.id))}/>
                              )}
                            </div>
                          </div>
                          <div className="text-xs text-gray-600 space-y-1">
                            <div>{RULE_TYPES[r.ruleType]?.icon || 'üìù'} {RULE_TYPES[r.ruleType]?.name || r.extractionType}</div>
                            <div>{DATA_TYPES[r.dataType]?.icon || 'üìù'} {DATA_TYPES[r.dataType]?.name || 'Text'}</div>
                            {r.testResults && (
                              <div className="text-green-600">
                                ‚úì {r.testResults.length} matches
                                {r.testResults.some(t => t.isEmpty) &&
                                  <span className="text-amber-600 ml-1">
                                    ({r.testResults.filter(t => t.isEmpty).length} empty)
                                  </span>
                                }
                              </div>
                            )}
                          </div>
                        </div>
                      ))}
                    </div>
                    <button
                      onClick={() => {
                        const templateName = prompt('Template name?') || `Template ${templates.length + 1}`;

                        if (hierarchyMode) {
                          // Save hierarchy template
                          if (!hierarchyStack.length) return;
                          const cleanStack = hierarchyStack.map(level => ({
                            ...level,
                            rules: level.rules.map(rule => sanitizeRuleForTemplate(rule, level.type))
                          }));
                          const newTemplate = {
                            name: templateName,
                            templateType: 'hierarchy',
                            hierarchy: {
                              stack: cleanStack,
                              settings: {
                                primaryLineIdentifier
                              }
                            },
                            excludePatterns,
                            created: new Date().toISOString()
                          };
                          // Include column mapping if enabled
                          if (columnMappingEnabled && columnMappingSpec?.boundaries?.length) {
                            newTemplate.columnMapping = {
                              version: 1,
                              smartSpec: {
                                boundaries: columnMappingSpec.boundaries
                              },
                              mapped: columnMappings
                            };
                          }
                          setTemplates([...templates, newTemplate]);
                        } else {
                          // Save simple template
                          if (!rules.length) return;
                          const cleanRules = rules.map(rule => sanitizeRuleForTemplate(rule, 'primary'));
                          const newTemplate = {
                            name: templateName,
                            templateType: 'simple',
                            rules: cleanRules,
                            excludePatterns,
                            created: new Date().toISOString()
                          };
                          // Include column mapping if enabled
                          if (columnMappingEnabled && columnMappingSpec?.boundaries?.length) {
                            newTemplate.columnMapping = {
                              version: 1,
                              smartSpec: {
                                boundaries: columnMappingSpec.boundaries
                              },
                              mapped: columnMappings
                            };
                          }
                          setTemplates([...templates, newTemplate]);
                        }
                      }}
                      className="mt-4 w-full px-3 py-2 bg-green-500 text-white rounded text-sm hover:bg-green-600"
                    >
                      üíæ Save Rules as Template
                    </button>
                  </div>

                  {/* Templates section */}
                  <div className="bg-white p-4 rounded shadow">
                    <h3 className="font-semibold mb-3 flex items-center gap-2">üìÇ Templates ({templates.length})</h3>
                    {templates.length === 0 && (<p className="text-sm text-gray-500">No templates yet. Save rules to create one.</p>)}
                    <div className="space-y-2">
                      {templates.map((t, idx) => (
                        <div key={idx} className="text-sm py-3 px-3 rounded border-l-4 border-gray-300 bg-gray-50">
                          <div className="flex items-center justify-between mb-2">
                            <span className="font-medium">{t.name}</span>
                            <div className="flex gap-2">
                              <button 
                                onClick={() => applyTemplate(t)}
                                className="text-blue-600 hover:text-blue-800 text-xs"
                              >
                                Apply
                              </button>
                              <button 
                                onClick={() => exportTemplates(t)}
                                className="text-green-600 hover:text-green-800 text-xs"
                                title="Export this template"
                              >
                                Export
                              </button>
                              <XIcon size={14} className="cursor-pointer text-red-500 hover:text-red-700" onClick={() => setTemplates(templates.filter((_, i) => i !== idx))}/>
                            </div>
                          </div>
                          <div className="text-xs text-gray-600 space-y-1">
                            <div className="flex items-center gap-2">
                              {t.templateType === 'hierarchy' ? (
                                <span className="font-medium text-purple-700">
                                  üèóÔ∏è {t.hierarchy?.stack?.length || 0} Levels
                                </span>
                              ) : (
                                <span className="font-medium">
                                  üìù {t.rules?.length || 0} Rules
                                </span>
                              )}

                              {t.excludePatterns?.length > 0 && (
                                <span className="text-gray-600">
                                  ‚Ä¢ üö´ {t.excludePatterns.length} Exclusions
                                </span>
                              )}
                            </div>
                            {t.rules?.slice(0, 2).map((rule, ruleIdx) => (
                              <div key={ruleIdx} className="text-xs text-gray-500">
                                {rule.ruleType === 'APPEND' ? '  ‚Ü≥ ' : '‚Ä¢ '}{rule.fieldName}
                                {rule.ruleType === 'APPEND' && (
                                  <span className="text-green-600 ml-1">(append)</span>
                                )}
                                {rule.description && (
                                  <span className="italic ml-1">- {rule.description}</span>
                                )}
                                {rule.sampleMatches?.length > 0 && (
                                  <span className="ml-1 text-gray-400">
                                    (e.g., {rule.sampleMatches[0]})
                                  </span>
                                )}
                              </div>
                            ))}
                            {t.rules?.length > 2 && (
                              <div className="text-xs text-gray-400 italic">
                                ...and {t.rules.length - 2} more fields
                              </div>
                            )}
                          </div>
                        </div>
                      ))}
                    </div>
                    <div className="mt-4 flex gap-2">
                      <button 
                        onClick={exportTemplates}
                        className="flex-1 px-3 py-2 bg-blue-500 text-white rounded text-sm hover:bg-blue-600"
                      >
                        üì§ Export Templates
                      </button>
                      <input ref={templateImportRef} type="file" accept=".json" className="hidden" onChange={handleImportTemplates} />
                      <button 
                        onClick={() => templateImportRef.current.click()}
                        className="flex-1 px-3 py-2 bg-purple-500 text-white rounded text-sm hover:bg-purple-600"
                      >
                        üì• Import Templates
                      </button>
                    </div>
                  </div>
                </aside>
              </div>

              {/* Exclusion Options Modal */}
              {showExcludeOptions && pendingExclusion && (
                <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
                  <div className="bg-white rounded-lg shadow-xl w-full max-w-3xl m-4 max-h-[90vh] overflow-auto">
                    <div className="p-6 border-b">
                      <h3 className="text-lg font-semibold">Choose Exclusion Pattern</h3>
                      <p className="text-sm text-gray-600 mt-1">Selected: "{pendingExclusion.text}"</p>
                    </div>
                    
                    <div className="p-6 space-y-4">
                      <div className="text-sm text-gray-700 mb-4">
                        Choose how broadly this exclusion should apply. More flexible patterns will exclude similar lines with different numbers, dates, etc.
                      </div>
                      
                      {pendingExclusion.patterns.map((pattern, idx) => {
                        const preview = previewExclusion(pattern);
                        return (
                          <div key={idx} className="border rounded p-4 hover:bg-gray-50 cursor-pointer"
                               onClick={() => {
                                 setExcludePatterns([...excludePatterns, pattern]);
                                 setShowExcludeOptions(false);
                                 setPendingExclusion(null);
                               }}>
                            <div className="flex items-center justify-between mb-2">
                              <div className="font-medium text-gray-800">
                                {pattern.isRegex ? 'üîç' : 'üìù'} {pattern.name}
                              </div>
                              <div className="text-sm text-blue-600">
                                Will exclude {preview.length} lines
                              </div>
                            </div>
                            <div className="text-sm text-gray-600 mb-2">{pattern.description}</div>
                            {pattern.isRegex && (
                              <div className="text-xs text-gray-500 font-mono bg-gray-100 px-2 py-1 rounded mb-2">
                                Pattern: /{pattern.pattern}/i
                              </div>
                            )}
                            
                            {preview.length > 0 && (
                              <div className="mt-3">
                                <div className="text-xs font-medium text-gray-700 mb-1">Preview of excluded lines:</div>
                                <div className="max-h-32 overflow-auto bg-red-50 border border-red-200 rounded p-2">
                                  {preview.slice(0, 10).map((line, lineIdx) => (
                                    <div key={lineIdx} className="text-xs text-red-700 py-1">
                                      Line {line.lineNumber}: {line.content || '(empty line)'}
                                    </div>
                                  ))}
                                  {preview.length > 10 && (
                                    <div className="text-xs text-red-600 italic">
                                      ... and {preview.length - 10} more lines
                                    </div>
                                  )}
                                </div>
                              </div>
                            )}
                          </div>
                        );
                      })}
                    </div>

                    <div className="p-6 border-t bg-gray-50 flex justify-end gap-3">
                      <button 
                        onClick={() => {
                          setShowExcludeOptions(false);
                          setPendingExclusion(null);
                        }}
                        className="px-4 py-2 border border-gray-300 rounded hover:bg-gray-100"
                      >
                        Cancel
                      </button>
                    </div>
                  </div>
                </div>
              )}


              {/* Rule Builder Modal */}
              {showRuleBuilder && (currentSelection || editingRule) && (
                <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
                  <div className="bg-white rounded-lg shadow-xl w-full max-w-2xl m-4 max-h-[90vh] overflow-auto">
                    <div className="p-6 border-b">
                      <h3 className="text-lg font-semibold">{editingRule ? 'Edit Extraction Rule' : 'Create Extraction Rule'}</h3>
                      <p className="text-sm text-gray-600 mt-1">
                        {editingRule ? `Editing: "${editingRule.fieldName}"` : currentSelection ? `Selected: "${currentSelection.text.slice(0, 50)}..."` : ''}
                      </p>
                    </div>
                    
                    <div className="p-6 space-y-4">
                      <div>
                        <label className="block text-sm font-medium mb-2">Rule Type</label>
                        <div className="grid grid-cols-1 gap-2">
                          {Object.entries(RULE_TYPES).map(([key, type]) => (
                            <button
                              key={key}
                              onClick={() => {
                                setRuleType(key);
                                // When switching to POSITION mode, prefill with "column:" to guide user
                                // unless already a valid position pattern
                                if (key === 'POSITION' && !pattern.startsWith('column:') && !pattern.startsWith('line:')) {
                                  setPattern('column:');
                                }
                                // When switching away from POSITION, clear if it was just "column:"
                                if (key !== 'POSITION' && (pattern === 'column:' || pattern === 'line:')) {
                                  setPattern('');
                                }
                              }}
                              className={`p-3 border rounded text-left ${ruleType === key ? 'border-blue-500 bg-blue-50' : 'border-gray-200'}`}
                            >
                              <div className="font-medium">{type.icon} {type.name}</div>
                              <div className="text-xs text-gray-600">{type.description}</div>
                            </button>
                          ))}
                        </div>
                      </div>

                      <div className="grid md:grid-cols-2 gap-4">
                        <div>
                          <label className="block text-sm font-medium mb-1">Field Name</label>
                          <input 
                            type="text" 
                            value={fieldName}
                            onChange={(e) => setFieldName(e.target.value)}
                            className="w-full px-3 py-2 border rounded"
                            placeholder="e.g., Account Number"
                          />
                        </div>
                        <div>
                          <label className="block text-sm font-medium mb-1">Data Type</label>
                          <select 
                            value={dataType}
                            onChange={(e) => setDataType(e.target.value)}
                            className="w-full px-3 py-2 border rounded"
                          >
                            {Object.entries(DATA_TYPES).map(([key, type]) => (
                              <option key={key} value={key}>{type.icon} {type.name}</option>
                            ))}
                          </select>
                        </div>
                      </div>

                      {hierarchyMode && (
                        <div>
                          <label className="block text-sm font-medium mb-1">Assign to Hierarchy Level</label>
                          <select
                            value={selectedHierarchyLevel || ''}
                            onChange={(e) => setSelectedHierarchyLevel(e.target.value || null)}
                            className="w-full px-3 py-2 border rounded"
                          >
                            <option value="">Choose a level...</option>
                            {hierarchyStack.map((level, index) => (
                              <option key={level.id} value={level.id}>
                                {level.type === 'detail' ? 'üìã' : level.type === 'append' ? '‚ûï' : 'üìÑ'} {level.name} ({level.rules.length} rules)
                              </option>
                            ))}
                            <option value="new-detail">+ Create New Detail Level</option>
                            <option value="new-append">+ Create New Append Level</option>
                            <option value="new-footer">+ Create New Footer Level</option>
                          </select>
                          <div className="text-xs text-gray-500 mt-1">
                            Select an existing level or create a new one for this rule
                          </div>
                        </div>
                      )}

                      {/* NEWLY ADDED CONDITIONAL SETTINGS */}
                      {hierarchyMode && hierarchyStack.find(l => l.id === selectedHierarchyLevel)?.type === 'append' && (
                        <div className="grid md:grid-cols-2 gap-4 mt-4 pt-4 border-t">
                          <div>
                            <label className="block text-sm font-medium mb-1">Scope</label>
                            <select
                              value={appendScope}
                              onChange={(e) => setAppendScope(e.target.value)}
                              className="w-full px-3 py-2 border rounded"
                            >
                              <option value="proximity">Until next primary</option>
                              <option value="indent">By indentation level</option>
                              <option value="fixed">Fixed line count (15)</option>
                            </select>
                          </div>
                          <div>
                            <label className="block text-sm font-medium mb-1">Empty Values</label>
                            <select
                              value={appendOnEmpty}
                              onChange={(e) => setAppendOnEmpty(e.target.value)}
                              className="w-full px-3 py-2 border rounded"
                            >
                              <option value="null">null</option>
                              <option value="empty">""</option>
                              <option value="na">N/A</option>
                            </select>
                          </div>
                        </div>
                      )}

                      <div>
                        <label className="block text-sm font-medium mb-1">Description (Optional)</label>
                        <input 
                          type="text" 
                          value={ruleDescription}
                          onChange={(e) => setRuleDescription(e.target.value)}
                          className="w-full px-3 py-2 border rounded"
                          placeholder="e.g., Purchase order number from header"
                        />
                        <div className="text-xs text-gray-500 mt-1">
                          Helps identify this rule's purpose in templates
                        </div>
                      </div>

                      <div>
                        <label className="block text-sm font-medium mb-1">
                          {ruleType === 'PATTERN' ? 'Regex Pattern' : 
                          ruleType === 'POSITION' ? 'Position Rule' : 'Extraction Rule'}
                        </label>
                        <div className="relative">
                          <input
                            type="text"
                            value={pattern}
                            onChange={(e) => {
                              setPattern(e.target.value);
                              // Test pattern when user changes it
                              setTimeout(() => testPattern(), 100);
                            }}
                            onKeyUp={(e) => {
                              // Trigger immediate testing for simple patterns like "column:X"
                              const currentPattern = e.target.value;
                              if (currentPattern.match(/^column:\d+$/) || currentPattern.match(/^column:\d+-\d+$/)) {
                                setTimeout(() => testPattern(), 50); // Faster for column patterns
                              } else if (currentPattern.length > 2) {
                                // Debounced testing for other patterns to avoid excessive updates
                                clearTimeout(window.patternTestTimeout);
                                window.patternTestTimeout = setTimeout(() => testPattern(), 150);
                              }
                            }}
                            className="w-full px-3 py-2 border rounded font-mono text-sm pr-10"
                            placeholder={RULE_TYPES[ruleType]?.examples[0]}
                          />
                          {ruleType === 'PATTERN' && (
                            <div className="absolute right-2 top-2">
                              <select 
                                onChange={(e) => {
                                  if (e.target.value) {
                                    setPattern(e.target.value);
                                    e.target.value = ''; // Reset dropdown
                                  }
                                }}
                                className="text-xs bg-gray-100 border rounded px-1 py-1 cursor-pointer"
                                value=""
                              >
                                <option value="">Quick Patterns ‚ñº</option>
                                <option value="LABEL:\s*(.*?)(?:\s{2,}|$)">LABEL: (multi-word/empty)</option>
                                <option value="LABEL[ \t\u00A0]+(\S+)">LABEL: (single word)</option>
                                <option value="LABEL:\s+(.+?)(?:\s|$)">LABEL: (stops at space)</option>
                                <option value="LABEL:\s+(.+)">LABEL: (whole line)</option>
                                <option value="(.+)">Whole line match</option>
                                <option value="(\d+)">Numbers only</option>
                                <option value="([A-Z-]+)">Codes (caps/dashes)</option>
                                <option value="LABEL\s*(.*?)(?:\s{2,}|$|TERMINATOR\s)">LABEL (with TERMINATOR)</option>
                              </select>
                            </div>
                          )}
                        </div>
                        <div className="text-xs text-gray-500 mt-1">
                          {ruleType === 'PATTERN' ? 
                            'Use Quick Patterns dropdown or type custom regex. Replace LABEL with your text.' :
                            `Examples: ${RULE_TYPES[ruleType]?.examples.join(' ‚Ä¢ ')}`
                          }
                        </div>
                      </div>

                      <div>
                        <label className="block text-sm font-medium mb-2">
                          Test Results ({testResults.length} matches)
                          {isTestingPattern && <span className="text-blue-600 ml-2">‚Ä¢ Testing...</span>}
                        </label>
                        <div className="border rounded max-h-32 overflow-auto bg-gray-50 p-2">
                          {isTestingPattern && (
                            <div className="text-blue-600 text-sm animate-pulse">üîÑ Testing pattern...</div>
                          )}
                          {!isTestingPattern && testResults.length === 0 && <div className="text-gray-500 text-sm">No matches found</div>}
                          {!isTestingPattern && testResults.map((result, idx) => (
                            <div key={idx} className={`text-sm py-1 ${result.error ? 'text-red-600' : result.isEmpty ? 'text-amber-600' : 'text-green-700'}`}>
                              {result.error || (result.isEmpty ? '(empty)' : result.value)}
                            </div>
                          ))}
                        </div>
                      </div>
                    </div>

                    <div className="p-6 border-t bg-gray-50 flex justify-end gap-3">
                      <button 
                        onClick={() => {
                          setShowRuleBuilder(false);
                          setIsTestingPattern(false); // Stop any ongoing testing
                          setEditingRule(null); // Reset editing state
                        }}
                        className="px-4 py-2 border border-gray-300 rounded hover:bg-gray-100"
                      >
                        Cancel
                      </button>
                      <button 
                        onClick={() => saveRule()}
                        disabled={!fieldName || !pattern || testResults.length === 0}
                        className="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 disabled:opacity-50"
                      >
                        {editingRule ? 'Save Changes' : 'Create Rule'}
                      </button>
                    </div>
                  </div>
                </div>
              )}

              {/* Simple selection panel for backward compatibility */}
              {selectionMode && currentSelection && !showRuleBuilder && (
                <div className="fixed bottom-6 right-6 bg-white border rounded shadow-lg p-4 float-panel w-72 space-y-3">
                  <h4 className="font-semibold text-sm mb-1">Create Extraction Rule</h4>
                  <p className="text-xs text-gray-600">"{currentSelection.text.slice(0,40)}"</p>
                  <input type="text" placeholder="Field Name" className="w-full px-2 py-1 border rounded text-sm" onKeyDown={(e)=>{ if(e.key==='Enter'){ createRule(e.target.value,'single'); setCurrentSelection(null);} }}/>
                  <div className="flex gap-2 text-xs">
                    <button onClick={()=>{createRule(null,'single'); setCurrentSelection(null);}} className="flex-1 bg-blue-600 text-white py-1 rounded">Single Value</button>
                    <button onClick={()=>{createRule(null,'all'); setCurrentSelection(null);}} className="flex-1 bg-green-600 text-white py-1 rounded">All Similar</button>
                  </div>
                  <button onClick={()=>setCurrentSelection(null)} className="absolute top-1 right-1 text-gray-400 hover:text-gray-600"><XIcon size={14}/></button>
                </div>
              )}

              {showRegexAssistant && (
                <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
                  <div className="bg-white rounded-lg shadow-xl w-full max-w-4xl m-4 max-h-[90vh] overflow-auto">
                    
                    {/* Header */}
                    <div className="p-6 border-b bg-gradient-to-r from-purple-50 to-blue-50">
                      <h3 className="text-lg font-semibold text-gray-800">‚ú® AI Regex Pattern Generator</h3>
                      <p className="text-sm text-gray-600 mt-1">
                        Paste 5-10 sample records from your document (include both primary lines and indented sub-lines)
                      </p>
                    </div>
                    
                    {/* Content */}
                    <div className="p-6 space-y-4">
                      
                      {/* Input Area */}
                      <div>
                        <label className="block text-sm font-medium text-gray-700 mb-2">
                          Sample Document Lines:
                        </label>
                        <textarea
                          value={regexInputText}
                          onChange={(e) => setRegexInputText(e.target.value)}
                          rows={12}
                          className="w-full px-3 py-2 border border-gray-300 rounded-lg font-mono text-sm focus:ring-2 focus:ring-purple-500 focus:border-transparent"
                          placeholder={`Example:

PART: 000-A Widget Assembly
   VENDOR: ACME-CORP
   PRICE: 45.50

PART: 001-B Valve Kit
   VENDOR: DELTA-SUPPLY
   PRICE: 28.75`}
                        />
                      </div>
                      
                      {/* Generate Button */}
                      <button
                        onClick={() => generateRegexPatterns(regexInputText)}
                        disabled={isGeneratingRegex || !regexInputText.trim()}
                        className="w-full px-4 py-2 bg-purple-600 text-white rounded-lg hover:bg-purple-700 disabled:opacity-50 disabled:cursor-not-allowed font-medium transition-colors"
                      >
                        {isGeneratingRegex ? "üîÑ Analyzing..." : "Analyze & Generate Patterns ‚Üí"}
                      </button>
                      
                      {/* Error Display */}
                      {regexError && (
                        <div className="bg-red-50 border border-red-200 rounded-lg p-4">
                          <div className="flex items-start gap-2">
                            <span className="text-red-600 text-lg">‚ö†Ô∏è</span>
                            <div className="flex-1">
                              <div className="font-medium text-red-800">Error</div>
                              <div className="text-sm text-red-700 mt-1">{regexError}</div>
                            </div>
                          </div>
                        </div>
                      )}
                      
                      {/* Results */}
                      {regexSuggestions.length > 0 && (
                        <div className="space-y-3 mt-6">
                          <h4 className="font-semibold text-gray-800 flex items-center gap-2">
                            <span>Suggested Patterns</span>
                            <span className="text-xs text-gray-500 font-normal">
                              (ordered by confidence)
                            </span>
                          </h4>
                          
                          {regexSuggestions.map((suggestion, idx) => {
                            const confidenceStyles = {
                              high: {
                                bg: "bg-green-50",
                                border: "border-green-300",
                                badge: "bg-green-100 text-green-800",
                                text: "text-green-900"
                              },
                              medium: {
                                bg: "bg-yellow-50",
                                border: "border-yellow-300",
                                badge: "bg-yellow-100 text-yellow-800",
                                text: "text-yellow-900"
                              },
                              low: {
                                bg: "bg-orange-50",
                                border: "border-orange-300",
                                badge: "bg-orange-100 text-orange-800",
                                text: "text-orange-900"
                              }
                            };
                            
                            const style = confidenceStyles[suggestion.confidence] || confidenceStyles.low;
                            
                            return (
                              <div key={idx} className={`border ${style.border} ${style.bg} rounded-lg p-4`}>
                                
                                {/* Header Row */}
                                <div className="flex items-center justify-between mb-3">
                                  <span className={`text-xs font-semibold uppercase px-2 py-1 rounded ${style.badge}`}>
                                    {suggestion.confidence} Confidence
                                  </span>
                                  <button
                                    onClick={() => {
                                      setPrimaryLineIdentifier(suggestion.pattern);
                                      setShowRegexAssistant(false);
                                      setRegexInputText('');
                                      setRegexSuggestions([]);
                                      setRegexError(null);
                                    }}
                                    className="px-4 py-1.5 bg-white border border-gray-300 rounded-lg text-sm font-medium hover:bg-gray-50 transition-colors"
                                  >
                                    Use This Pattern
                                  </button>
                                </div>
                                
                                {/* Pattern Display */}
                                <div className="bg-white rounded-lg p-3 mb-3 border border-gray-200">
                                  <div className="text-xs text-gray-500 mb-1 font-medium">Regex Pattern:</div>
                                  <code className="text-sm font-mono text-gray-800 break-all">
                                    {suggestion.pattern}
                                  </code>
                                </div>
                                
                                {/* Explanation */}
                                <p className={`text-sm ${style.text} mb-2`}>
                                  {suggestion.explanation}
                                </p>
                                
                                {/* Match Count */}
                                {suggestion.matchCount > 0 && (
                                  <div className="text-xs text-gray-600 flex items-center gap-1">
                                    <span className="text-green-600">‚úì</span>
                                    Matches <strong>{suggestion.matchCount}</strong> lines in your document
                                  </div>
                                )}
                                
                                {suggestion.matchCount === 0 && (
                                  <div className="text-xs text-amber-600 flex items-center gap-1">
                                    <span>‚ö†Ô∏è</span>
                                    No matches found - this pattern may be too specific
                                  </div>
                                )}
                                
                              </div>
                            );
                          })}
                          
                          {/* Refinement Hint */}
                          <div className="bg-blue-50 border border-blue-200 rounded-lg p-3 text-sm text-blue-800">
                            <strong>üí° Tip:</strong> Test patterns using the "Highlight Primary Records" checkbox to see which lines are matched in your document.
                          </div>
                        </div>
                      )}
                      
                    </div>
                    
                    {/* Footer */}
                    <div className="p-6 border-t bg-gray-50 flex justify-end gap-3">
                      <button
                        onClick={() => {
                          setShowRegexAssistant(false);
                          setRegexInputText('');
                          setRegexSuggestions([]);
                          setRegexError(null);
                        }}
                        className="px-4 py-2 border border-gray-300 rounded-lg hover:bg-gray-100 transition-colors"
                      >
                        Close
                      </button>
                    </div>
                    
                  </div>
                </div>
              )}
            </>
          )}
        </div>
      );
      } catch (error) {
        console.error('‚ùå Error in AdvancedDocumentExtractor:', error);
        return (
          <div className="p-8 bg-red-50 border border-red-200 rounded">
            <h1 className="text-2xl font-bold text-red-800 mb-4">Error Loading App</h1>
            <p className="text-red-600 mb-4">{error.message}</p>
            <details className="text-sm">
              <summary className="cursor-pointer font-medium">Stack Trace</summary>
              <pre className="mt-2 p-2 bg-red-100 rounded text-xs overflow-auto">{error.stack}</pre>
            </details>
        </div>
      );
      }
    }

    console.log('üéØ Rendering AdvancedDocumentExtractor...');
    ReactDOM.createRoot(document.getElementById('root')).render(<AdvancedDocumentExtractor/>);
  </script>
</body>
</html>

